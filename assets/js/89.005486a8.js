(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{360:function(n,e,t){"use strict";t.r(e);var o=t(22),s=Object(o.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"重学js-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重学js-对象","aria-hidden":"true"}},[n._v("#")]),n._v(" 重学js----对象")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("定义:")]),n._v(" "),t("pre",[t("code",[n._v(" ES5                                 ES6\n var obj={                         var obj={\n     属性: 值                    \n     name:'xx',                      name:'xx',\n     say:function(){                 say(){\n\n     }                                 }\n }\n")])])]),n._v(" "),t("li",[t("p",[n._v("删除对象的属性")]),n._v(" "),t("pre",[t("code",[n._v(" delete 属性名   =====>     delete obj.name;\n")])])]),n._v(" "),t("li",[t("p",[n._v("创建对象方法")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("对象字面量/对象直接量")]),n._v(" "),t("pre",[t("code",[n._v("  var obj={} \n")])])]),n._v(" "),t("li",[t("p",[n._v("构造函数:(必须带有"),t("code",[n._v("new")]),n._v(")")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("函数自带的构造函数")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("new Object")]),n._v("   ===>  var obj=new Object()")])])]),n._v(" "),t("li",[t("p",[n._v("自定义(定义类的方式)")]),n._v(" "),t("pre",[t("code",[n._v("   funtion Cat(){\n       this.name='BMW'\n       this.height='1400'\n   }\n   var person1=new Person()\n")])])])])]),n._v(" "),t("li",[t("p",[n._v("构造函数内部原理")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("在函数体最前面隐式加上 "),t("code",[n._v("var that={}")])])]),n._v(" "),t("li",[t("p",[n._v("执行 "),t("code",[n._v("that.__proto__ = 函数对象.prototype")])])]),n._v(" "),t("li",[t("p",[n._v("执行"),t("code",[n._v("that.xx=xx")])])]),n._v(" "),t("li",[t("p",[n._v("隐式返回"),t("code",[n._v("that")]),n._v(" (如果显示返回 "),t("code",[n._v("return {} 那么就是空对象")]),n._v("  如"),t("code",[n._v("果返回的是原始值 那么就会忽略原始值 依旧返回隐式this")]),n._v(")")]),n._v(" "),t("pre",[t("code",[n._v("  funtion Cat(){\n      //var obj={} 声明一个空对象\n      // obj.__proto__=this.prototype 挂载\n      // 赋值属性 \n     this.name='BMW'\n     this.height='1400'\n     // return this; 隐式返回\n }\n var person1=new Person();\n")])])])]),n._v(" "),t("p",[n._v("模拟构造函数内部:")]),n._v(" "),t("pre",[t("code",[n._v("    funtion person(){\n        var that={};\n        that.name;\n        return that;\n    }\n")])])])])]),n._v(" "),t("li",[t("p",[n._v("包装对象:(属性和方法只能是对象有的，原始值是没有属性和方法的);")]),n._v(" "),t("pre",[t("code",[n._v(" var str='abc';\n str+=1; //'abc1';\n var test=typeof(str) //'string'\n if(test.lengt == 6){//true\n     test.sign='typeof的返回结果可能为string'\n }\n console.log(test.sign)//undefined\n")])])])]),n._v(" "),t("hr"),n._v(" "),t("pre",[t("code",[n._v("    function Person(name,age,sex){\n        var a=0;\n        this.name=name;\n        this.age=age;\n        this.sex=sex;\n        function sss(){\n            a++;//关联在外面的a\n            console.log(a)\n            console.log(this);//this 指向Person\n        }\n        this.say=sss;//形成了闭包 等于\n        this.say=function(){\n            a++;//关联在外面的a\n            console.log(a)\n            console.log(this);//this 指向Person\n        }\n    }\n    var oPerson=new Person();\n    oPerson.say();//1\n    oPerson.say();//2\n    var oPerson1=new Person();// 构造函数中的属性是独立的\n    oPerson1.say();//1\n")])]),n._v(" "),t("hr"),n._v(" "),t("pre",[t("code",[n._v("var x=1,y=z=0 // ===》 var x=1; var y=z (y=0); window.z=0 直接声明是挂载到window上面的\nfunction add(n){ //会被下面的add函数覆盖\n    return n=n+1;\n}\ny=add(x); //4\nfunction add(n){\n    return n=n+3;\n}\nz=add(x) //4\n\nx,y,z的值分别是多少? 1 4 4\n")])]),n._v(" "),t("hr"),n._v(" "),t("pre",[t("code",[n._v("function b(x,y,a){\n    arguments[2]=10;//a 由3 ===> 10\n    console.log(a);//10\n}\nb(1,2,3)\n如果函数体改成下面的 \na=10;\nconsole.log(arguments[2])\n  function b(x,y,a){\n    a=10;//形参变成了10 依然会影响arguments\n    console.log(arguments[2]);//10\n}\nb(1,2,3)\narguments 与形参是相关联的\narguments 改变 形参值 会改变\n形参 改变 arguments 也会改变\n")])])])},[],!1,null,null,null);e.default=s.exports}}]);