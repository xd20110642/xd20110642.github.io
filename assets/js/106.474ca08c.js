(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{375:function(n,t,r){"use strict";r.r(t);var s=r(22),i=Object(s.a)({},function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h3",{attrs:{id:"函数的定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数的定义","aria-hidden":"true"}},[n._v("#")]),n._v(" 函数的定义")]),n._v(" "),r("h3",{attrs:{id:"函数的定义分为2种"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数的定义分为2种","aria-hidden":"true"}},[n._v("#")]),n._v(" 函数的定义分为2种")]),n._v(" "),r("pre",[r("code",[n._v("1. 一种是函数的表达式\n2. 一种是函数的声明 \n")])]),n._v(" "),r("ul",[r("li",[r("p",[n._v("如果是函数的声明 那么typesscript很容易就能够推导出类型")]),n._v(" "),r("pre",[r("code",[n._v("  function say(a:string):string{\n      return a;\n  }\n  注意:a为参数的类型  后面为返回值的类型  而且只有返回值类型为void 和any 不会强制要求有返回值 其他类型则必须有 返回值\n\n  带默认参数的函数声明\n  function say(a:string='1'):string{\n      return a;\n  }\n")])])]),n._v(" "),r("li",[r("p",[n._v("如果是函数的表达式 那么有2种方法来完成类型的推导")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("第一种 系统推导")]),n._v(" "),r("pre",[r("code",[n._v("  //非匿名函数\n  const say1=function(a:string,b:string):string{\n      return a+b\n  }\n  //箭头函数表达式\n  const say=(a:string,b:string):string => {}  //那么就可以推导出say的类型为string\n")])])]),n._v(" "),r("li",[r("p",[n._v("第二种 完整函数类型")]),n._v(" "),r("pre",[r("code",[n._v("  const say:(B:string) => string = function(x:string):string {return x}     \n  说明 say 这个变量是  函数类型  参数是string 返回 string类型\n  后面是定义的方式\n  \n  备注：\n  say的声明方式 可以写成接口  \n")])])])])]),n._v(" "),r("li",[r("p",[n._v("接口定义函数: 它就像是一个只有参数列表和返回值类型的函数定义")]),n._v(" "),r("pre",[r("code",[n._v("   interface SearchFunc {\n          (source: string, subString: string): boolean;\n   }\n")])])])])])},[],!1,null,null,null);t.default=i.exports}}]);