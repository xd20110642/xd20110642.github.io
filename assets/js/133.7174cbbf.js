(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{402:function(e,a,t){"use strict";t.r(a);var n=t(22),r=Object(n.a)({},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"watch实用技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch实用技巧","aria-hidden":"true"}},[e._v("#")]),e._v(" watch实用技巧")]),e._v(" "),t("hr"),e._v(" "),t("ul",[t("li",[t("p",[e._v("watch 的一个特点是，最初绑定的时候是不会执行的，要等到 firstName 改变时才执行监听计算。(但是在3.0中是默认初始化执行)")]),e._v(" "),t("pre",[t("code",[e._v("      watch: {\n      firstName: {//深度监听 可监听对象 和数组的变化\n          handler(newName, oldName) {\n          this.fullName = newName + ' ' + this.lastName;\n          },\n          // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法\n          immediate: true\n      }\n  }\n")])])])]),e._v(" "),t("p",[e._v("我们给 "),t("code",[e._v("firstName")]),e._v(" 绑定了一个"),t("code",[e._v("handler")]),e._v("方法，之前我们写的 "),t("code",[e._v("watch")]),e._v(" 方法其实默认写的就是这个"),t("code",[e._v("handler")]),e._v("，Vue.js会去处理这个逻辑，最终编译出来其实就是这个"),t("code",[e._v("handler")])]),e._v(" "),t("p",[e._v("参考链接:\n"),t("a",{attrs:{href:"https://juejin.im/post/5ae91fa76fb9a07aa7677543",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.im/post/5ae91fa76fb9a07aa7677543"),t("OutboundLink")],1)])])},[],!1,null,null,null);a.default=r.exports}}]);