(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{344:function(n,e,o){"use strict";o.r(e);var t=o(22),s=Object(t.a)({},function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h3",{attrs:{id:"宏任务和微任务"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务","aria-hidden":"true"}},[n._v("#")]),n._v(" 宏任务和微任务")]),n._v(" "),o("ul",[o("li",[o("p",[n._v("事件循环:同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。")]),n._v(" "),o("pre",[o("code",[n._v("  setTimeout(_ => console.log(4))\n\n  new Promise(resolve => {\n  resolve()\n  console.log(1)\n  }).then(_ => {\n  console.log(3)\n  })\n\n  console.log(2)\n  解析:\n  整体script作为第一个宏任务开始执行: 遇见第一个setTimeout 将其放入第二个宏任务队列 \n  执行new Peromise() resolve().then将其放入 第一个微任务队列 继续执行 打印 1\n  打印 2 第一个宏任务执行完毕  开始执行第一个宏任务队列里面的第一个微任务 打印3 第一个宏任务队列里面的微任务执行完毕 \n  开始执行第二个宏任务 打印4\n")])])])]),n._v(" "),o("p",[o("strong",[n._v("new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。")]),o("code",[n._v("同一次事件循环中，微任务永远在宏任务之前执行。")])]),n._v(" "),o("ul",[o("li",[o("p",[n._v("宏任务:(浏览器定义的)")]),n._v(" "),o("ul",[o("li",[o("p",[o("strong",[n._v("宏任务中可以创建微任务，但是在宏任务中创建的微任务不会影响当前宏任务的执行。")]),n._v("(将微任务 放置到当前宏任务队列的 微任务队列里面)")])]),n._v(" "),o("li",[o("p",[o("strong",[n._v("当一个宏任务队列中的任务全部执行完后，会查看是否有微任务队列，如果有就会优先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列")])]),n._v(" "),o("table",[o("thead",[o("tr",[o("th",[n._v("#")]),n._v(" "),o("th",[n._v("浏览器")]),n._v(" "),o("th",[n._v("NODE")])])]),n._v(" "),o("tbody",[o("tr",[o("td",[n._v("/O")]),n._v(" "),o("td",[n._v("true")]),n._v(" "),o("td",[n._v("fasle")])]),n._v(" "),o("tr",[o("td",[n._v("setTimeout")]),n._v(" "),o("td",[n._v("true")]),n._v(" "),o("td",[n._v("true")])]),n._v(" "),o("tr",[o("td",[n._v("setInterval")]),n._v(" "),o("td",[n._v("true")]),n._v(" "),o("td",[n._v("true")])]),n._v(" "),o("tr",[o("td",[n._v("requestAnimationFrame(这个是用于数据渲染)")]),n._v(" "),o("td",[n._v("true")]),n._v(" "),o("td",[n._v("true")])]),n._v(" "),o("tr",[o("td",[n._v("setImmediate")]),n._v(" "),o("td",[n._v("false")]),n._v(" "),o("td",[n._v("true")])])])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("宏任务中可以创建微任务，但是在宏任务中创建的微任务不会影响当前宏任务的执行。")])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("可以有多个宏任务")])])])])]),n._v(" "),o("li",[o("p",[n._v("微任务:(js引擎定义 因为并不是挂载到window上面的)")]),n._v(" "),o("ul",[o("li",[o("code",[n._v("在上一个宏任务队列执行完毕后，如果有微任务队列就会执行微任务队列中的所有任务")])]),n._v(" "),o("li",[o("code",[n._v("new promise((resolve)=>{ 这里的函数在当前队列直接执行 }).then( 这里的函数放在微任务队列中执行 )")])]),n._v(" "),o("li",[o("code",[n._v("微任务队列上创建的微任务，仍会阻碍后方将要执行的宏任务队列")]),n._v("(也就是会在当前微任务队列里 执行完毕)")]),n._v(" "),o("li",[o("code",[n._v("由微任务创建的宏任务，会被丢在异步宏任务队列中执行")]),n._v("(会被放到 宏任务队列里面 也就是最后一个  如果当前宏任务是队列是1  那么被创建的宏任务 就是队列2 需要等到当前队列1的微任务执行完毕以后 才会执行 )")])])]),n._v(" "),o("li",[o("p",[n._v("举例:")]),n._v(" "),o("ul",[o("li",[o("p",[n._v("在微任务中创建微任务")]),n._v(" "),o("pre",[o("code",[n._v("   setTimeout(_ => console.log(4))\n   new Promise(resolve => {\n   resolve()\n   console.log(1)\n   }).then(_ => {\n   console.log(3)\n   Promise.resolve().then(_ => {\n   \tconsole.log('before timeout')\n   }).then(_ => {\n   \tPromise.resolve().then(_ => {\n   \tconsole.log('also before timeout')\n   \t})\n   })\n   })\n\n   console.log(2);\n   解析:\n   第一次加载是第一个宏任务: 将setTimeout 放入第二个宏任务队列 继续执行 new Promise resolve() 将其then 放入第一个 宏任务队列里面的 第一个微任务队列 继续执行 打印1 继续打印 2 第一个宏任务队列执行完毕 \n   开始执行第1个微任务 打印3 将第二个Promise.resolve().then放入 第一个宏队列的第2个微任务 继续执行第一个微任务的代码 \n   以此类推 然后打印 before timeout also before timeout 现在第一个宏队列的微任务队列全部执行完毕 开始执行第二个宏队列 打印4\n")])])]),n._v(" "),o("li",[o("p",[n._v("宏任务中创建微任务")]),n._v(" "),o("pre",[o("code",[n._v("  // 宏任务队列 1\n  setTimeout(() => {\n  // 宏任务队列 \n  console.log('timer_1');\n  setTimeout(() => {\n  \t// 宏任务队列 3\n  \tconsole.log('timer_3')\n  }, 0)\n  new Promise(resolve => {\n  \tresolve()\n  \tconsole.log('new promise')\n  }).then(() => {\n  \t// 微任务队列 1\n  \tconsole.log('promise then')\n  })\n  }, 0)\n\n  setTimeout(() => {\n  // 宏任务队列 2\n  console.log('timer_2')\n  }, 0)\n\n  console.log('========== Sync queue ==========')\n  解析:\n  第一个宏任务是 整个scrpit 遇见第一个定时器 放入 第二个宏任务 继续执行 遇见第二个定时器 放入第三个宏任务 继续执行 输出========== Sync queue ========== 第一个宏任务执行完毕 又没有第一个宏任务的微任务 \n  执行第二个宏任务 打印 timer_1 继续执行 将第三个定时器放入 第4个宏任务队列 继续执行new Promise 将then 放入第二个宏任务的第1个微任务 继续执行 打印console.log('new promise')  执行完毕 开始执行第二个宏任务的第一个微任务 console.log('promise then') 执行完毕\n  执行第三个宏任务 console.log('timer_2') \n  执行第4个 console.log('timer_3')\n")])])])])]),n._v(" "),o("li",[o("p",[n._v("总结：\n"),o("code",[n._v("**微任务队列优先于宏任务队列执行，微任务队列上创建的宏任务会被后添加到当前宏任务队列的尾端，微任务队列中创建的微任务会被添加到微任务队列的尾端。只要微任务队列中还有任务，宏任务队列就只会等待微任务队列执行完毕后再执行。**")])])]),n._v(" "),o("li",[o("p",[n._v("对于包含async和await的异步执行")]),n._v(" "),o("ul",[o("li",[o("p",[n._v("一旦遇到await 就立刻让出线程,阻塞后面的代码等候之后,对于await来说分两种情况")]),n._v(" "),o("ul",[o("li",[n._v("不是promise 对象:\n"),o("ul",[o("li",[n._v("如果await 后面直接跟的为一个变量，比如："),o("code",[n._v("await 1")]),n._v("；"),o("code",[n._v("这种情况的话相当于直接把await后面的代码注册为一个微任务，可以简单理解为promise.then(await下面的代码)")]),n._v("。然后跳出async1函数，执行其他代码，当遇到promise函数的时候，会注册promise.then()函数到微任务队列，注意此时微任务队列里面已经存在await后面的微任务。所以这种情况会先执行await后面的代码（async1 end），再执行async1函数后面注册的微任务代码(promise1,promise2)。 (举例"),o("strong",[n._v("demo1")]),n._v(")")])])]),n._v(" "),o("li",[n._v("是promise对象 (异步函数调用)\n"),o("ul",[o("li")])])]),n._v(" "),o("p",[o("s",[o("strong",[n._v("如果不是promise,await会阻塞后面的代码,先执行async外面的同步代码,同步代码执行完毕后,在回到async内部,把promise的东西,作为await表达式的结果\n如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。")])])]),n._v(" "),o("pre",[o("code",[n._v("demo1:\nasync function async1() {\nconsole.log( 'async1 start' )\nawait async2() //相当于是柱塞后面的代码 放入当前宏任务队列里面的第一个微任务队列\nconsole.log( 'async1 end' )\n}\nasync function async2() {\n\tconsole.log( 'async2' )\n}\nasync1()\nconsole.log( 'script start' );\n输出:\nasync1 start -> async2 -> script start ->  async1 end\n")])]),n._v(" "),o("br"),n._v(" "),o("pre",[o("code",[n._v("async function async1() {\n    console.log( 'async1 start' ) ---\x3e 第一个输出\n    await async2() ---\x3e 执行函数 函数执行完毕 返回到这里 然后退出 async1函数\n    console.log( 'async1 end' ) ---\x3e 第5个输出 第一个宏任务的同步代码执行完毕 准备执行第一个宏任务的微任务\n}\nasync function async2() {\n    console.log( 'async2' )  ---\x3e 第二个输出\n}\nconsole.log( 'script start' ) \nsetTimeout( function () {\n    console.log( 'setTimeout' )  ---\x3e 第二个宏任务\n}, 0 )\nasync1(); ----\x3e 第一个执行\nnew Promise( function ( resolve ) {\n    console.log( 'promise1' )  ---\x3e 执行同步函数 第三个输出 执行完毕后 就返回到async1中继续执行\n    resolve();\n} ).then( function () {\n    console.log( 'promise2' )   ---\x3e 第六个输出\n} )\nconsole.log( 'script end' ) ---\x3e 第4个输出\n")])]),n._v(" "),o("p",[o("strong",[n._v("await会阻塞后面的代码,先执行async外面的同步代码,同步代码执行完毕后,在回到async内部,把promise的东西,作为await表达式的结果")])]),n._v(" "),o("p",[o("strong",[n._v("在执行 async 函数时，碰到了 await 的话，会立即执行紧跟 await 的语句，然后把后续代码推入微任务队列（以这种形式去理解，实际执行并非如此）。")])]),n._v(" "),o("pre",[o("code",[n._v("const syn1 = () => console.log(2)\nconst syn2 = () => new Promise((r, j)=>r()).then(()=>console.log(3))\n\nasync function asyncFunc () {\nconsole.log('start')\nawait console.log(1);\nawait syn1()\nawait syn2()\nconsole.log('end')\nreturn 7\n}\n\nsetTimeout(() => console.log(5), 0)\nconsole.log(0)\nasyncFunc().then(v => console.log(v))\nnew Promise((r, j)=>r()).then(() => console.log(6))\nconsole.log(4)\n执行步骤:\n第一步:\n输入 0 执行第一个函数asyncFunc();\n第二步:\nasyncFunc() => 输入 start 等待执行完毕await console.log(1);  输入 1 \n然后跳出asyncFunc函数 就后面所以没有执行的内容全部推出优先级最高的微任务队列\n第三步:\n继续执行第一个宏任务\n输入 4 第一个宏任务同步代码执行完毕 返回到asyncFunc()继续执行\n第4步:\n执行await syn1() 等待 输出2 然后 退出asyncFunc() 函数 再把后面没有执行的任务 推入微任务 \n第5步:\n执行外面函数的微任务\n输入 6 返回到asyncFunc()继续执行\n第6步:\n执行await syn2() 等待 输出3 然后 退出asyncFunc() 函数 再把后面没有执行的任务 推入微任务 \n第7步:\n外部没有同步任务了 返回到asyncFunc()继续执行\n第8步：\n输出 end  并且返回7 \n第9步 :\n执行第二个宏任务 输出5\n")])])])])])]),n._v(" "),o("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-1337770fcc29d10325ee4eb127496fff_720w.jpg"}}),n._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[n._v("宏任务需要多次事件循环才能执行完，微任务是一次性执行完的；\n一个宏任务完成以后 会把所有的微任务执行完毕")]),n._v(" "),o("li",[n._v("宏任务macrotask：\n（事件队列中的每一个事件都是一个macrotask）")])]),n._v(" "),o("p",[n._v("优先级：主代码块 > setImmediate > MessageChannel > setTimeout / setInterval")]),n._v(" "),o("p",[n._v("比如：setImmediate指定的回调函数，总是排在setTimeout前面\n5.微任务包括：\n优先级：process.nextTick > Promise > MutationObserver")]),n._v(" "),o("ul",[o("li",[n._v("在微任务添加的微任务 是添加在当前微任务队列里面的最后一个微任务")]),n._v(" "),o("li",[n._v("参考链接:https://www.lagou.com/lgeduarticle/21830.html")]),n._v(" "),o("li",[n._v("https://www.cnblogs.com/jiangyuzhen/p/11064408.html")])])])},[],!1,null,null,null);e.default=s.exports}}]);