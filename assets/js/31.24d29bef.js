(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{300:function(t,e,s){"use strict";s.r(e);var i=s(22),v=Object(i.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"vue中解构this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue中解构this","aria-hidden":"true"}},[t._v("#")]),t._v(" vue中解构this")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[s("p",[t._v("在vue组件中的this 指向的是vue当前组件的实例,在上面挂载了我们定义在上面的data 和计算属性等等")])]),t._v(" "),s("li",[s("p",[t._v("当我们在某处只需要读取而不是赋值的时候,使用"),s("code",[t._v("this.xx会觉的很繁琐")]),t._v(",其实我们可以使用"),s("code",[t._v("解构的方式来解决,在vue的template模式下解构出来变量是只读的 是不能被修改的")]),t._v("但是在"),s("code",[t._v("render函数下面 就是可读可写的")])]),t._v(" "),s("pre",[s("code",[t._v("  this.xx  如果只是读取 我们只需要 let {xx}=this \n  xx === this.xx 区别就是 this.xx是可读可写的  xx是保证了 读取的值是 this.xx的值  但是如果给xx 赋值 那么 this.xx !== xx\n")])])]),t._v(" "),s("li",[s("p",[t._v("因为解构会造成响应式数据的丢失 "),s("strong",[t._v("这个问题在vue3中可以使用toRefs()来解决")])])]),t._v(" "),s("li",[s("p",[t._v("为什么解构会照常响应式数据的丢失?")]),t._v(" "),s("pre",[s("code",[t._v("  因为在js中有2种值的传递方式 原始类型是值传递  引用类型是引用类型传递\n  然后解构就是声明的一个原始类型来完成读取变量里面的 就相当于是值传递 \n  值传递是拷贝的一份值 而不是指向的对象的地址 所以当对象改变的时候 而我们解构所读取的值 不会有任何变化 \n  所以这样就照成了 响应式对象的丢失！\n  参考如下图\n")])])])]),t._v(" "),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/11/10/16e55bf60e474672?imageslim"}})])},[],!1,null,null,null);e.default=v.exports}}]);