(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{346:function(t,a,n){"use strict";n.r(a);var e=n(22),o=Object(e.a)({},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"浅拷贝与深拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝与深拷贝","aria-hidden":"true"}},[t._v("#")]),t._v(" 浅拷贝与深拷贝")]),t._v(" "),n("ul",[n("li",[t._v("深拷贝和浅拷贝只是针对Obejct和Array引用数据类型的")]),t._v(" "),n("li",[n("strong",[t._v("浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。")])])]),t._v(" "),n("h3",{attrs:{id:"赋值和浅拷贝的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#赋值和浅拷贝的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 赋值和浅拷贝的区别")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。")]),t._v(" "),n("pre",[n("code",[t._v("  \t//浅拷贝\n     var obj3={\n           'name': 'zhangsan',//普通类型\n         'age': '18',\n         'language': [1, [2, 3], [4, 5]],//引用类型\n     } \n    function shallowCopy(params) {\n        var data={}\n        for (const key in params) {\n          //   判断是否存在这个 也就是\n            if (params.hasOwnProperty(key)) {\n               data[key] = params[key]\n                \n            }\n        }\n        return data;\n    }    \n     var obj4=shallowCopy(obj3);\n     obj3.name=\"xd\"; //这样修改普通的值 不会影响到obj4  如果修改到 language 引用类型 那么就会影响到 obj4\n     console.log('obj4',obj4) \n      console.log('obj3', obj3)\n")])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/23/167da74d45d3103b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v("    r")])])]),t._v(" "),n("h3",{attrs:{id:"浅拷贝的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝的实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 浅拷贝的实现")]),t._v(" "),n("pre",[n("code",[t._v('* Object.assign()\t\n\t1. Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身\n\t\n\t\t\tvar obj = { a: {a: "kobe", b: 39} };\n\t\t\tvar initalObj = Object.assign({}, obj);\n\t\t\tinitalObj.a.a = "wade";\n\t\t\tconsole.log(obj.a.a); //wade\n   1. 如果object只有一层的时候 是深拷贝\n   \t\t\t\n\t\t   \tlet obj = {\n\t\t    username: \'kobe\'\n\t\t    };\n\t\t\tlet obj2 = Object.assign({},obj);\n\t\t\tobj2.username = \'wade\';\n\t\t\tconsole.log(obj);//{username: "kobe"}\n* concat\n* slice\n')])]),t._v(" "),n("p",[t._v("原数组的元素会按照下述规则拷贝：")]),t._v(" "),n("pre",[n("code",[t._v("1. 如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n2. 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。\n")])]),t._v(" "),n("p",[t._v("参考链接"),n("img",{attrs:{src:"",alt:"https://juejin.im/post/5b5dcf8351882519790c9a2e"}})])])},[],!1,null,null,null);a.default=o.exports}}]);