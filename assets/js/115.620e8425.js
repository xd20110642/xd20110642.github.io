(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{383:function(t,a,n){"use strict";n.r(a);var e=n(22),s=Object(e.a)({},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"vue-nuxt-服务端渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-nuxt-服务端渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" vue-nuxt 服务端渲染")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("asyncData 和data 的区别")]),t._v(" "),n("p",[t._v("官方说了，asyncData 是在 vue 页面创建期间调用，用于给页面变量进行赋值的数据。")]),t._v(" "),n("p",[t._v("和 data 之间的区别就是，在 SSR 渲染过程中这部分数据会被加载到页面上，SEO 可以检索到这部分数据。")]),t._v(" "),n("p",[t._v("而你在 mounted 中获取的数据需要先保存到 data 中再进行渲染，所以如果你的数据放在 mounted 中加载，SEO 是检索不到这部分数据的。")])])]),t._v(" "),n("hr"),t._v(" "),n("pre",[n("code",[t._v("最简单的答案是data（）在客户端处理，但是asyncData（）部分在服务器端处理Nuxt（）时处理一次，并在客户端再次处理。\nnuxt的最大优点是它能够在服务器端呈现内容。 如果您在客户端使用promise加载内容，例如在mounted部分中说：\njavascript代码将按原样发送到客户端，浏览器负责运行Promise从api获取数据。 但是，如果将promise放在asyncData中：\n数据获取是在服务器端完成的，结果将被预渲染，并将包含数据（渲染到其中）的html发送到客户端。 因此，在这种情况下，客户端将不会接收用于自行处理api调用的javascript代码，而是会接收到以下内容：\n我们从asyncData返回的结果与数据中的内容合并。 它不会被替换但会合并。\n")])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://stackoverflow.com/questions/53569137/data-vs-asyncdata-in-nuxt-vue"}},[t._v("   参考文章")])])])},[],!1,null,null,null);a.default=s.exports}}]);