(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{331:function(o,n,e){"use strict";e.r(n);var v=e(22),a=Object(v.a)({},function(){var o=this,n=o.$createElement,e=o._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h3",{attrs:{id:"javascript如何将值传递给函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript如何将值传递给函数","aria-hidden":"true"}},[o._v("#")]),o._v(" JavaScript如何将值传递给函数")]),o._v(" "),e("ul",[e("li",[e("p",[o._v("javascript语言中的函数参数都是按值来传递的")])]),o._v(" "),e("li",[e("p",[o._v("值传递")]),o._v(" "),e("pre",[e("code",[o._v("  var test = 10;\n\n  function test2(test){ \n      ++test;\n  }\n\n  console.log(test) // 还是10\n")])]),o._v(" "),e("p",[e("code",[o._v("借用JavaScript高程上的话来讲：按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。")])])]),o._v(" "),e("li",[e("p",[o._v("引用传递")]),o._v(" "),e("pre",[e("code",[o._v("  var obj = {x : 1};\n  function foo(o) {\n      o.x = 3;\n  }\n  foo(obj);\n  console.log(obj.x); // 3, 被修改了!\n")])])])]),o._v(" "),e("p",[e("code",[o._v("按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。")])]),o._v(" "),e("ul",[e("li",[e("p",[o._v("共享传递")]),o._v(" "),e("pre",[e("code",[o._v(" var value = 1;\n  function foo(v) {\n      v = 2;\n      console.log(v); //2\n  }\n  foo(value);\n  console.log(value) // 1\n")])])])]),o._v(" "),e("p",[e("code",[o._v("首先foo(v)中的v确实复制了外部的value。然后将v指向栈内存中的2，所以只修改了foo内部的v的值。而外部的value却没有改变。")])]),o._v(" "),e("pre",[e("code",[o._v("    var obj = {\n        value: 1\n    };\n    function foo(o) {\n        o.value = 2;\n        console.log(o.value); //2\n    }\n    foo(obj);\n    console.log(obj.value) // 2\n")])]),o._v(" "),e("p",[e("code",[o._v("首先foo(o)中复制了外部obj的值。然后将o.value改为2，由于o还是引用着外部的obj对象，所以相当于是改变了原来的指向值 { value: 1 }，变成了{ value: 2 }，所以obj的引用指向最后的更新值 { value: 2 }。")])]),o._v(" "),e("pre",[e("code",[o._v("var obj = {\n    value: 1\n};\nfunction foo(o) {\n    o = 2;\n    console.log(o); //2\n}\nfoo(obj);\nconsole.log(obj.value) // 1\n")])]),o._v(" "),e("p",[e("code",[o._v("变量obj引用指向值 { value: 1 }，foo 执行时形参对实参做一次复制使得形参o引用也是指向值 { value: 1 }，这里注意o并不是指向obj；接着执行o = 2，相当于更新了o的引用，使o引用指向常量2，但是其实我们并没有改变原来的指向值 { value: 1 }，所以obj的引用指向值是没有变的。")])]),o._v(" "),e("ul",[e("li",[e("p",[o._v("综上所述:\n基本类型传递是值传递 不会影响到实参的值\n对于传递到函数参数的"),e("code",[o._v("对象类型")]),o._v("，"),e("strong",[o._v("如果直接改变了拷贝的引用的指向地址，那是不会影响到原来的那个对象")]),o._v("；"),e("strong",[e("code",[o._v("如果是通过拷贝的引用，去进行内部的值的操作，那么就会改变到原来的对象的。")])])])]),o._v(" "),e("li",[e("p",[o._v("参考链接\n"),e("a",{attrs:{href:"https://juejin.im/post/5af392206fb9a07acf562859"}},[o._v("https://juejin.im/post/5af392206fb9a07acf562859\n"),e("a",{attrs:{href:"https://juejin.im/post/5beb934df265da61797460fd"}},[o._v("https://juejin.im/post/5beb934df265da61797460fd")])])])])])])},[],!1,null,null,null);n.default=a.exports}}]);