(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{395:function(t,e,a){"use strict";a.r(e);var r=a(22),v=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"vue计算属性和观察属性的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue计算属性和观察属性的差异","aria-hidden":"true"}},[t._v("#")]),t._v(" vue计算属性和观察属性的差异")]),t._v(" "),a("p",[t._v("---(非源码解释)---")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("计算属性")]),t._v(":只有依赖的变量发生了改变，返回的结果才会修改(会缓存 如果变量在修改前和修改后的值是一样的 则不会触发计算属性 )")]),t._v(" "),a("li",[a("code",[t._v("观察属性")]),t._v(":监听数据的改变")])]),t._v(" "),a("p",[t._v("---(源码解释)---")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("computed")]),t._v(":是判断依赖数据的setter是否被触发 如果触发了 进行对比 如果setter和上次setter不一样 就会通知computed 的watch方法update更新这个计算属性")]),t._v(" "),a("li",[a("code",[t._v("watch")]),t._v(":就是只要触发了依赖的数据的setter 就会触发watch的update更新这个数据")])])])},[],!1,null,null,null);e.default=v.exports}}]);