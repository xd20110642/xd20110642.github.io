(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{314:function(n,e,t){"use strict";t.r(e);var o=t(22),r=Object(o.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"解构注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解构注意事项","aria-hidden":"true"}},[n._v("#")]),n._v(" 解构注意事项")]),n._v(" "),t("hr"),n._v(" "),t("pre",[t("code",[n._v("     let obj={name:'小米',age:8}\n     let {name,age}=obj //解构 \n     ===\n     let name=obj.name  //这个是基础类型 是拷贝了值 而不是地址 \n     所以修改name 并不会影响到 obj里面的值\n")])]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("解构可以查找到原型链上面，也就是说可以追查到"),t("code",[n._v("null")])]),n._v(" "),t("pre",[t("code",[n._v("    class Logger {\n        printName(name = 'there') {\n            this.print(`Hello ${name}`);\n        }\n\n        print(text) {\n            console.log(text);\n        }\n    }\n\n    const logger = new Logger();\n    const { printName } = logger;\n    logger的实例上面没有 printName 那么我们解构出来的 printName 就应该为undefined 但是 printName 输出的是确是原型链上的方法 说明解构可以查找到原型链上\n")])]),n._v(" "),t("p",[n._v("对象的解构赋值可以取到继承的属性")]),n._v(" "),t("pre",[t("code",[n._v("    const obj1 = {};\n    const obj2 = { foo: 'bar' };\n    Object.setPrototypeOf(obj1, obj2);//设置原型链  obj1的原型被设置为obj2\n\n    const { foo } = obj1;\n    foo // \"bar\"\n")])])])},[],!1,null,null,null);e.default=r.exports}}]);