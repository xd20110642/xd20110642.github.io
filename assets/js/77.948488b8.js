(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{353:function(n,e,t){"use strict";t.r(e);var a=t(22),r=Object(a.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"易错易忘记的知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#易错易忘记的知识点","aria-hidden":"true"}},[n._v("#")]),n._v(" 易错易忘记的知识点")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("匿名函数的立即执行表达式")]),n._v(" "),t("pre",[t("code",[n._v("  (function(){})() 转换为 匿名函数 (x => console.log(x))()\n")])]),n._v(" "),t("p",[n._v("另外匿名函数的this指向的是其  最外层的普通函数 不能使用"),t("code",[n._v("new")]),n._v(" 当作构造函数")])]),n._v(" "),t("li",[t("p",[n._v("json和JavaScript的转换")]),n._v(" "),t("pre",[t("code",[n._v("  JSON.parse() ===>  将json转化为JavaScript\n  JSON.stringify() ===> 将JavaScript转化为JSON\n")])])]),n._v(" "),t("li",[t("p",[n._v("关于"),t("code",[n._v("object key")]),n._v("的自动转化")]),n._v(" "),t("pre",[t("code",[n._v('  const a={}\n  const b={key:\'1\'}\n  const c={key:\'2\'}\n  a[b]=123; //  b.toString() ===> "[object Object]" ===> a["[object Object]"]=123;\n  a[c]=456;//同理 a["[object Object]"]=456; 对同一个key赋值会覆盖掉上面的值\n  console.log(a[b])// 456 \n  对象的key 只能为string和symbol 如果不是string和symbol 那么就会发生隐世转换\n  所以上面的代码可转义为\n')])])]),n._v(" "),t("li",[t("p",[n._v("对象默认是不可以迭代的")])]),n._v(" "),t("li",[t("p",[n._v("数组的"),t("code",[n._v("reduce")]),n._v("方法")]),n._v(" "),t("pre",[t("code",[n._v("  arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n  callback:执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数\n  accumulator:累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue(初始值)（见于下方）。\n  currentValue:数组中正在处理的元素\n  index 可选数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。\n  array可选调用reduce()的数组\n  initialValue可选:作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。\n  举例:\n  const arr=[[1,2],[3,4]]\n  arr.reduce((function 回调函数(累计器返回的值`如果有初始值那么就是初始值`,当前的值）{},初始值)\n  arr.reduce((acc,cur) => {\n  \treturn acc.concat(cur)\n  },[0,1])\n  需要处理的数组是 arr \n  acc 累加器 因为有初始值 所以它的值为 [0,1]\n  cur 是当前的值 也就是第一个值 [1,2]\n  当执行第一次的时候 acc=[0,1,1,2] 现在的acc就是\n  acc [0,1,1,2]\n  cur 就是 [3,4]\n  最后的值就是 [0,1,1,2,3,4]\n")])])]),n._v(" "),t("li",[t("p",[n._v("数组去重 Set")]),n._v(" "),t("pre",[t("code",[n._v("  let arr=[1,1,2,3]\n  console.log(new Set(arr)) ===> {1,2,3}\n  Set返回的是类数组而不是数组 因为使用new的返回的基本都是对象\n")])])]),n._v(" "),t("li",[t("p",[n._v("对象的结构")]),n._v(" "),t("pre",[t("code",[n._v("  let {name} ={name:'23'} //这个是声明一个name变量 \n  let {name:age}={name:'23'}// age='23' name是一个匹配 而age才是真正的变量 只有真正的变量才能被赋值\n")])])]),n._v(" "),t("li",[t("p",[n._v("import和require的区别")]),n._v(" "),t("ul",[t("li",[n._v("CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。（也就是只有执行了才会有对象的生成 而import 是在浏览器解析语法树的时候 就会执行了）")]),n._v(" "),t("li",[n._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。(可以理解为 基本类型和引用类型的差异)\n"),t("ul",[t("li",[n._v("每一个 CommonJS 都是独立的模块(是值的拷贝)")]),n._v(" "),t("li",[n._v("而es6是一个值的引用(指向的是同一个指针 修改一个 其他地方引用的数据依旧会改变)")])])])])]),n._v(" "),t("li",[t("p",[n._v("基本类型包装类使用的原理")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("首先我们需要明确一个道理 只有对象才有属性和方法的 基本类型是没有属性和方法的\n这个在我以前的博客里面有详细的解释,")]),n._v(" "),t("pre",[t("code",[n._v("  var a='123' //基本类型\n  a.length===>3 //上面我们不是说到基本类型是没有属性和方法的嘛 其实这个地方有一个隐式的转换\n  第一步:\n  var _a=new String(a) 生成一个临时的字符串对象\n  第二步:\n  _a.length=3  //输出我们的结果\n  第三步\n  销毁这个临时的字符串对象\n  这样就输出了我们日常用来判断字符串长度的方法\n  \n  也可以这样理解\n  var b='123'\n  b.length=0 //==> 如果基本类型能修改那么 b是不是就变成了一个空字符串了\n  console.log(b) ==> b='123';\n  原理同上 \n  第一步: \n  var _b=new String('123');\n  _b.length=0;\n  第三步 销毁这个临时对象\n  \n  综上所述:只要是基本类型 使用只读的方式来获取信息是可以了 如果要修改是不能成立的\n  这一点在vue3.0里面就有将基本类型使用 ref 将 基本类型转换为响应式包装对象的处理\n")])])])])]),n._v(" "),t("li",[t("p",[n._v("使用"),t("code",[n._v("object.freeze()")]),n._v("冻结对象:不能对属性进行添加 修改 删除 但仅仅只是浅冻结（类似于浅拷贝一样）")]),n._v(" "),t("pre",[t("code",[n._v("  \tconst a={name:'23'}\n  \tObject.freeze(a)\n  \tconst b=a;\n  \tb.name='1'\n  \tconsole.log(b.name) ===> '23' 因为冻结的是一个地址 \n  \t所以b 指向的是 a的地址  所以b也无法修改 如果 name是一个引用对象的话 那么就可以修改\n")])])]),n._v(" "),t("li",[t("p",[n._v("这个this的指向")]),n._v(" "),t("pre",[t("code",[n._v("  \tvar value = 1;\n\n  \tvar foo = {\n  \t  value: 2,\n  \t  bar: function () {\n  \t    return this.value;\n  \t  }\n  \t}\n  \tconsole.log((false || foo.bar)()); // 1\n  \t第一步拆分:\n  \t\tfalse || foo.bar  ===>  这个是 或 运算 带有逻辑短路的知识\n  \t\t如果 第一个是true 那么就返回第一个 否则返回第二个  所以这个地方返回的是 指向 foo.bar的指针\n  \t\t&& 运算 如果第一个是false 那么就直接返回false 否则返回第二个\n  \t第二步:\n  \t\t运行这个指针指向的地址\n  \t\t相当于是 var a=function(){return this.value}  a() \n  \t\t因为a是全局 所以this等于window 所以输出1 这个相关内容在我前面的博客写过的 \n  \t\t考验的就是this的丢失 react也是如此\n")])])]),n._v(" "),t("li",[t("p",[n._v("基本类型和引用类型的比较:")]),n._v(" "),t("pre",[t("code",[n._v("  \tvar a=1;var b=1;\n  \ta === b //true\n  \t基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的\n  \t==  会发生类型转换\n\n  \t\n  \tvar a = [1,2,3];\n  \tvar b = [1,2,3];\n  \tconsole.log(a === b); // false\n  \t引用类型的比较是引用的比较\n  \t(都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象)\n  \t比较的是指针地址\n")])]),n._v(" "),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/9/3/a32ee86b9f3e303216d19240441cedfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"}})]),n._v(" "),t("li",[t("p",[n._v("setDate() 设置当前时间对象的指定时间")]),n._v(" "),t("pre",[t("code",[n._v("  var dd=new Date() //当前时间对象 dd 为3月1号\n  dd.setDate(15) ;// 然后当前时间对象 dd 就变成了 3月15号")])])])])])},[],!1,null,null,null);e.default=r.exports}}]);