(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{380:function(t,n,e){"use strict";e.r(n);var v=e(22),_=Object(v.a)({},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"再次学习vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再次学习vue","aria-hidden":"true"}},[t._v("#")]),t._v(" 再次学习Vue")]),t._v(" "),e("h3",{attrs:{id:"不使用构建版本-使用网页版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不使用构建版本-使用网页版本","aria-hidden":"true"}},[t._v("#")]),t._v(" 不使用构建版本,使用网页版本")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在实例化的时候，是大写的 Vue")]),t._v(" "),e("p",[t._v("响应式的数据")]),t._v(" "),e("pre",[e("code",[t._v("\tvar data = {\n\t\t\ta: 1\n\t\t\t}\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: data\n\t\t\t})\ndata.b=1;//这个就不是响应式的了 因为实例化后才注入的\n")])]),t._v(" "),e("p",[t._v("现在data里面的a才是响应式的，因为他是在实例化前 就应经是被注入了,对b的改动不会触发视图的任何改动\n"),e("strong",[t._v("可以使用修改 但是这个地方稍后补偿")]),t._v("\n主要是针对数组和对象来说   通过下标来修改vue不能监听到")]),t._v(" "),e("pre",[e("code",[t._v("arr:[1,2,3]\narr[0]=a =>vue监听不生效\nvue.set(arr,0,a) => 生效\t\n\n使用Vue.set(object,key,value) <===>vm.set(object,key,value)\n这样就可以将其修改为响应式数据\nvm.$set(vm.data,'age',26) ===> data{a:1,age:26}\n实例会暴露出以$开头的方法\n\n例如：vm.$data ===data  \nvm.$el===document.getElementById('app');\n")])])])]),t._v(" "),e("p",[t._v("生命周期钩子（最常用）：")]),t._v(" "),e("pre",[e("code",[t._v("created(){//初始化数据的生命周期钩子\n\n} \t\nmounted(){//DOM加载完毕的时候，使用操作DOM\n\n}\n")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("模板语法")]),t._v(" "),e("pre",[e("code",[t._v("  v-bind:href='xxx' --\x3e 绑定样式 缩写 ---\x3e  :href='xxx'\n  \n  v-on:click='one' ----\x3e 绑定事件  缩写 --\x3e @click='xxxx'\n")])])]),t._v(" "),e("li",[e("p",[t._v("计算属性和侦听属性")]),t._v(" "),e("pre",[e("code",[t._v("  计算属性定义的变量，可以不需要在data中定义  他是有缓存的 都需要有缓存机制\n  computed:{\n  \txxx(){\n  \treturn xxx\n  \t}\n  }\n  \n  侦听属性是需要现在data里面定义的\n  watch:{\n  \tquestion(new,old){\n  \t\t//new 是状态\n  \t\t//old 是旧状态\n  \t}\n  }\n")])])]),t._v(" "),e("li",[e("p",[t._v("class和style绑定")]),t._v(" "),e("p",[t._v("使用v-bind来绑定class和style  可以是单个字符串、数组、对象")])]),t._v(" "),e("li",[e("p",[t._v("对象语法")]),t._v(" "),e("pre",[e("code",[t._v('  <div :class="{active:isActive}"></div>\n')])]),t._v(" "),e("p",[t._v("active这个class的是否存在 取决于date中的isActive的是否存在")]),t._v(" "),e("pre",[e("code",[t._v('  <div :class="classObject></div>\t\n  \n  data:{\n  classObject:{\n  \tactive:true\n  }\n  }\n')])])]),t._v(" "),e("li",[e("p",[t._v("条件渲染")])]),t._v(" "),e("li",[e("p",[t._v("用key来做唯一标识")])]),t._v(" "),e("li",[e("p",[t._v("使用v-for把一个(数组、对象)对应为一组元素")]),t._v(" "),e("pre",[e("code",[t._v(' \tlet items=[1,2]\n //\t<li v-for="(item,key) in items" :key="index">\n \t//\t'+t._s(t.item)+"\n \t//</li>\t\t\n")])]),t._v(" "),e("ul",[e("li",[t._v("使用v-for来渲染 模板")])]),t._v(" "),e("ul",[t._l(t.items,function(n){return[e("li",[t._v(t._s(n.msg))]),t._v(" "),e("li",{staticClass:"divider",attrs:{role:"presentation"}})]})],2)]),t._v(" "),e("li",[e("p",[t._v("事件处理")]),t._v(" "),e("p",[t._v("一般不带括号")])]),t._v(" "),e("li",[e("p",[t._v("表单输入绑定")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("需要使用v-model 来完成双向数据绑定")])]),t._v(" "),e("li",[e("p",[t._v("多选框的使用方法")]),t._v(" "),e("pre",[e("code",[t._v('    <select v-model="selected">\n      <option disabled value="">请选择</option>\n      <option>A</option>\n      <option>B</option>\n      <option>C</option>\n  </select>\n')])])]),t._v(" "),e("li",[e("p",[t._v("修饰符 .lazy")]),t._v(" "),e("pre",[e("code",[t._v('  将input事件转化为Chage事件进行同步\n  v-model.lazy="a"\n')])])])])]),t._v(" "),e("li",[e("p",[t._v("组件基础")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定义一个组件\t并且是全局组件")]),t._v(" "),e("pre",[e("code",[t._v("Vue.component('组件名称',{\n\ttemplate:'#app',//这个地方可以使用template来完成\n\tdata(){\n\treturn {\n\t\n\t}\n\t}\n})\n\n<template id=\"app\">\n//就和组件里面的内容对应起来了\n\n</template>\t\n")])])]),t._v(" "),e("li",[e("p",[t._v("通过prop向子组件传递数据")]),t._v(" "),e("pre",[e("code",[t._v("  通过属性绑定的方法来完成数据的传递\n  <xd :name=\"xxxx\"></xd>\n  组件接受\n  props:['name']\n")])])]),t._v(" "),e("li",[e("p",[t._v("通过事件监听来完成 子组件对父组件的完成")])]),t._v(" "),e("li",[e("pre",[e("code",[t._v("  \t\t<xd @click=\"a\"></xd>\t\n  \t\t子组件通过：this.$emit('xx')来完成触发\n  **最优的解决方法 是使用vuex**\t\t\n")])])]),t._v(" "),e("li",[e("p",[t._v("插槽\n如果在组件中间需要自定义内容例如")]),t._v(" "),e("pre",[e("code",[t._v("  <template>\n  \t<div>\n  \t\t<p>xxx</p>\n  \t</div>\n  </template>\n  \n  <xd>xxxxx</xd>  ===> 会报错\n  \n  但是如果在模板中加入插槽<solt></solt>那么就不会报错\n  \n  <template>\n  \t<div>\n  \t\t<p>xxx</p>\n  \t\t<solt></solt>\n  \t</div>\n  </template>\n  \n  \t<xd>xxxxx</xd>  ===> 不会报错\n")])])])])]),t._v(" "),e("li",[e("p",[t._v("prop")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("可以初始化定义传入的props的类型和初始化值")]),t._v(" "),e("pre",[e("code",[t._v("  \tprops:{\n  \ttitle:String,\n  \tlikes:{\n  \t\ttype：Number,\n  \t\tdefault:1\n  \t},\n  \tarr:{//定义数组和对象的默认值，必须从一个工厂函数获取\n  \ttype:object,\n  \tdefault(){\n  \treturn {mess:'hello}\n  \t},\n  \tfunc:{//自定义验证函数\n  \tvalidator(value){\n  \t// 这个值必须匹配下列字符串中的一个\n    return ['success', 'warning','danger'].indexOf(value) !== -1\t\t}\n  \t}\n  \t}\n  \t}\n")])])]),t._v(" "),e("li",[e("p",[t._v("使用props:['a'],中的数据是使用"),e("strong",[t._v("this.a来完成使用")])])])])]),t._v(" "),e("li",[e("p",[t._v("插槽")]),t._v(" "),e("ul",[e("li",[t._v("使用普通插槽")])]),t._v(" "),e("p",[t._v("在组件的内部直接使用")]),t._v(" "),e("pre",[e("code",[t._v('  <template id="hear">\n          <div style="width:100%;height:200px;background:pink">\n          我是头部组件\n          <slot></slot>\n      </div>\n  </template>\n  \n  <hear>我是使用了普通插槽的方法了</hear>\n')])])]),t._v(" "),e("li",[e("p",[t._v("使用具名插槽")]),t._v(" "),e("pre",[e("code",[t._v('  \t组件\n  \t<hear>\n  \t\t  <template slot="foo">\n                 <h1>Here might be a page title</h1>\n             </template>\n  \t</hear>\n  \t   \n \t\t<template id="hear">\n             <div>\n                 <slot name="foo"></slot>\n       \t\t  </div>\n     </template>\t\n     \n 指定渲染 具名插槽需要使用 templte 来完成\n')])])]),t._v(" "),e("li",[e("p",[t._v("动态组件和异步组件")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("使用keep-alive来完成对组件的缓存，避免组件重复渲染,使用is来切换不同的组件")]),t._v(" "),e("keep-live",[e("pre",[e("code",[t._v("  <hear></hear>\n")])])])],1)])]),t._v(" "),e("li",[e("p",[t._v("访问元素&组件")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("通过DOM直接访问组件")]),t._v(" "),e("pre",[e("code",[t._v('  <div ref="aaa"></div>\n  \n  this.$refs.aaa\n')])])])])]),t._v(" "),e("li",[e("p",[t._v("过渡效果")])]),t._v(" "),e("li",[e("p",[t._v("使用插件")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("通过全局方法使用插件")]),t._v(" "),e("pre",[e("code",[t._v("  Vue.use() //需要在new Vue实例化前 完成\n  \x3c!--也可以传递一个选项对象--\x3e\n  Vue.use(xxx,{aaa:true})\t\t\t\n")])])])])]),t._v(" "),e("li",[e("p",[t._v("过滤器")]),t._v(" "),e("pre",[e("code",[t._v("  1. 在"+t._s(t._f("xxx")(t.mess))+" //在花括号中\n  2. 在 <div v-bind:id=\"rawId|xxx\"></div>\t\n  3. 定义全局过滤器\n  \n  Vue.filter('过滤器名字',function(value){//value就是我们|前面的内容  value是我们传入的参数 \n  if(!value){\n  \treturn ''\n  }\n  value=value.toString()\n  return xxxx;\n  \n  })\n")])])]),t._v(" "),e("li",[e("p",[t._v("带参数的过滤器")]),t._v(" "),e("pre",[e("code",[t._v(" \t//"+t._s(t._f("filterA")(t.message,"arg1",t.arg2))+"\n \n filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 就是相当于mess就是需要我们过滤的信息\t\t\n")])])]),t._v(" "),e("li",[e("p",[t._v("混入属性")]),t._v(" "),e("p",[t._v("执行顺序:混入先执行,原生的后执行 注意：不是覆盖而是分别执行一次")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定义混入对象 我们可以再混入对象里面使用完整的vue的所有方法和事件")]),t._v(" "),e("pre",[e("code",[t._v("  \t\t//定义混入对象\n  \t\tvar myminxin={\n  \t\t\tcreated(){\n  \t\t\t\tthis.hello //这个this指向我们混入的vue对象实例\n  \t\t\t}\n  \t\t}\n")])])]),t._v(" "),e("li",[e("p",[t._v("实例化")]),t._v(" "),e("pre",[e("code",[t._v("  var vm=new Vue({\n  \tmixins:[我们定义的混入对象的名字]\n  })\t\n")])])])])])]),t._v(" "),e("p",[t._v("16 动态组件 使用 component 组件来完成对组件的动态显示")]),t._v(" "),e("pre",[e("code",[t._v('根据is 来动态切换组件\n\n<component :is="componentId"></component>\n')])]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"细节知识点-使用vue的插件过滤器都必须在vue实例化之前定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#细节知识点-使用vue的插件过滤器都必须在vue实例化之前定义","aria-hidden":"true"}},[t._v("#")]),t._v(" #细节知识点\n###使用vue的插件过滤器都必须在vue实例化之前定义")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("打印vue实例,里面会有一些以$符号为前缀的一些属性.这些就是我们可以访问的特殊的Vue属性")])]),t._v(" "),e("li",[e("p",[t._v("vue常用实例属性和方法\n"),e("img",{attrs:{src:"https://www.w3cplus.com/sites/default/files/blogs/2017/1711/Vue-propertype-methods.png",alt:"图片展示"}})]),t._v(" "),e("p",[t._v("2.1 全局API")]),t._v(" "),e("p",[t._v("Vue.extend:使用基础Vue构造器，创建一个“子类”。参数是一个包含组件选项的对象著作权归作者所有。")]),t._v(" "),e("p",[t._v("Vue.nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM  "),e("strong",[t._v("修改数据以后调用 就是更新数据以后 立刻操作DOM")])]),t._v(" "),e("p",[t._v("Vue.set：设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制")]),t._v(" "),e("p",[t._v("Vue.delete：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开Vue不能检测到属性被删除的限制，但是你应该很少会使用它")]),t._v(" "),e("p",[t._v("Vue.directive：注册或获取全局指令")]),t._v(" "),e("p",[t._v("Vue.filter：注册或获取全局过滤器")]),t._v(" "),e("p",[t._v("Vue.component：注册或获取全局组件。注册还会自动使用给定的id设置组件的名称")]),t._v(" "),e("p",[t._v("Vue.use：安装Vue.js插件")]),t._v(" "),e("p",[t._v("Vue.mixin：全局注册一个混合，影响注册之后所有创建的每个Vue实例")]),t._v(" "),e("p",[t._v("Vue.compile：在render函数中编译模板字符串。只在独立构建时有效")]),t._v(" "),e("p",[t._v("简化声明周期\n"),e("img",{attrs:{src:"https://www.w3cplus.com/sites/default/files/blogs/2017/1711/vue-instances-and-life-cycles-12.png",alt:"简化生命周期"}})])]),t._v(" "),e("li",[e("p",[t._v("watch观察者")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("函数接受2个参数 一个是新值,一个是旧值")])]),t._v(" "),e("li",[e("p",[t._v("删除观察者")]),t._v(" "),e("p",[t._v("每当我们使用$watch方法时，它实际上会返回一个函数，然后我们可以调用它来停止观察脚本中后面的更改")]),t._v(" "),e("p",[t._v("var unwatch = vm.$watch('a', cb)// 之后取消观察unwatch()")])])])]),t._v(" "),e("li",[e("p",[t._v("使用methods的注意点")]),t._v(" "),e("pre",[e("code",[t._v("1.在调用methods定义的方法时，一定得加上小括号()，不然输出的将是整个函数中的字符，类似下图这样\n2.不能使用es6的箭头函数 只能使用es5语法，否则会照常不能联系到上线文\n")])]),t._v(" "),e("p",[t._v("###与computed的差异:\n1.从作用机制上看")]),t._v(" "),e("p",[t._v("computed:是以Vue的依赖追踪机制为基础的，其试图处理这样的一件事情：当某一个数据（依赖数据）发生变化的时候，所有依赖这个数据的相关数据会自动发生变化，也就是自动调用相关的函数去实现数据的变动")]),t._v(" "),e("p",[t._v("methods:是用来定义函数的，它需要手动调用才能执行，而不像computed那样，可以自动执行预先定义的函数")]),t._v(" "),e("p",[t._v("总结:methods里面定义的函数 是需要主动调用的，而computed定义的函数是会自动调用的,完成 我们希望完成的作用")]),t._v(" "),e("p",[t._v("2.从性质上看\ncomputed:是计算属性，事实上和data对象里面的数据属性是同意类"),e("br"),t._v("\nmethods:是定义的函数,是想JavaScript中的funtion()函数这样去调用他")]),t._v(" "),e("p",[t._v("##computed擅长使用的是:一个数据受多个数据的影响")])])]),t._v(" "),e("p",[t._v("计算属性的变量：是不用提前声明的")]),t._v(" "),e("p",[t._v("5.事件")]),t._v(" "),e("pre",[e("code",[t._v('1. <p @click="gerr"></p>\t//单纯调用 是不用写 括号的\n2. 如果要传入原生DOM 需要传入特殊变量$event\n')])]),t._v(" "),e("p",[t._v("6.组件通信\n"),e("img",{attrs:{src:"https://www.w3cplus.com/sites/default/files/blogs/2019/1902/vue-component-data-communication-1.png",alt:"组件通信"}}),t._v("\n1.父组件获取子组件的数据和事件可以通过")]),t._v(" "),e("pre",[e("code",[t._v('\t1.通过给子组件绑定ref属性来获取子组件实例\n\t\t\n\t\t<my ref="re"></my>\n\t\t\n\t\t----\n\t\tnew Vue({\n\t\t\tmethods:{\n\t\t\t a(){\n\t\t\t //获取到子组件实例\n\t\t\t \tthis.$refs \n\t\t\t }\n\t\t\t}\n\t\t})\n\t2. 通过this.$children来获取子组件的实例\n\t\t//获取到子组件实例\n\t\tthis.$children\n')])]),t._v(" "),e("p",[t._v("2.子组件获取父组件数据和事件")]),t._v(" "),e("pre",[e("code",[t._v("\t1.通过props传递父组件的数据和事件,或者通过$emit和$on完成事件传递\n\t2.通过使用this.$parent.$data 或者 this.$parent.$_data获取父组件数据,通过this.$parent执行父组件方法\n\t父组件\n\tmethods:{\n\t\the(){\n\t\t}\n\t}\n\t子组件内部:\n\t获取到父组件的信息\n\tthis.$parent.$data\n\t调用方法\n\tthis.$parent.he(可传参数)\n")])]),t._v(" "),e("p",[t._v("3.兄弟组件的数据通信和事件传递")]),t._v(" "),e("pre",[e("code",[t._v('\t1.eventBus挂载全局事件\n\tvar bus=new Vue();\n\t子组件1：\n\tbus.$emit(\'do\',\'参数\')//发送\n\t子组件2:\n\tbus.$on(\'do\',(参数) => {//接受\n\t\tconsole.log(\'12\')\n\t})\t\t\n\t2.利用$parent进行数据传递，使用$parent.$children调用兄弟组件事件 **目前没有弄懂**\n\t3.使用$attrs和$listeners来实现数据之间的通信。\n\t\n\t利用$attrs实现祖孙组件间的数据传递，$listeners实现祖孙组件间的事件监听。\n\t$attrs是一个属性的集合 \n\t**包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)  也就是需要v-bind来绑定的 但是只是没有在props里面使用**\n\t$listeners是一个事件的集合,2着都是以对象的形式来保持数据的\n\t\n\t<my :name="xx" :age="a" :tow="to"></my>\n\t\n\t子组件\n\tprops:[\n\tname\n\t]\n\t然后获取到\n\tthis.$attrs  ==> age 因为age没有在props中使用\n\t使用\n\tthis.$listeners.two => 就可以调用 父组件的to方法\n\t---\n\t父组件\n\tdata(){\n\t\tname:\n\t\tage:\n\t},\n\tmethods:{\n\t\tto(){\n\t\t\n\t\t}\n\t}\n\t\n\t<top>\n\t    <center>\n\t        <bottom>\n\t        </bottom>\n\t    </center>\n\t</top>\n\t\n\t需求 top和bottom通信 数据交互\n\t\n\t<top @getClick="xx" @get="xx" :name="xx" :age="xx">\n\t\n\t\t<center v-on="$listeners" v-bind="$attrs">\n\t\t\t\n\t\t</center>\n\t\ncenter 组件中接收 age 那么age 就不会传递给\tbottom组件\n就只会把 A组件的name 传递给bottom组件  使用props接收\n但是 事件除了有.native的修饰符不能接收 其他的都能接受\n就可以直接调用 this.$emit(\'get\')即可\n\t\n如何引用\n1.声明一个js文件 然后 导出 在需要使用的地方 使用就可以了\n2.挂载到原型链上  先声明 一个实例  然后绑定到vue原型链上\t\n\t\n!(参考链接)[https://blog.csdn.net/qq_33559093/article/details/82878862]\t\n')])]),t._v(" "),e("p",[t._v("4.过渡")]),t._v(" "),e("pre",[e("code",[t._v("1.v-enter-active v-leave-active 用来定义离开过渡的过程时间，延迟和曲线函数\n2.v-enter v-leave-to 定义离开的动作 \n以上都是配合使用\n")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://www.w3cplus.com/sites/default/files/blogs/2018/1812/vue-transition-10.png",alt:"进入动画详解"}})]),t._v(" "),e("p",[t._v("Vue只能对transition中的一个元素进行动效处理。相反，在任何给定的实例中，只能将transition中的一个元素插入到DOM中著作权归作者所有。 如果需要多个那么只能使用 transition-group")]),t._v(" "),e("p",[t._v("5.混合")]),t._v(" "),e("p",[e("strong",[t._v("mixins是一个JavaScript对象")]),t._v(",可以包含组件中的任何选项")]),t._v(" "),e("pre",[e("code",[t._v("\t定义:\n\tmyminxs={\n\t\tmethods:{\n\t\ta(){console.log(1)}\n\t\t}\n\t}\n\t\n\t注入:\n\tvar vm=new Vue({\n\t\tmixins:[]//数组\n\t})\n\t在本地里面调用混合的方法 \n\tthis.a() ==> 即可调用\n")])]),t._v(" "),e("p",[t._v("混合的合并和冲突")]),t._v(" "),e("pre",[e("code",[t._v("1. 默认是mixins上会首先被注册，接着组件上的接着注册,  如果有多个混合选项 如果有相同项 前后的会被后面的覆盖\n2. mixins的合并有三种情况：数据data 声明周期钩子 键为对象的值\n")])]),t._v(" "),e("p",[t._v("1.数据合并")]),t._v(" "),e("pre",[e("code",[t._v("数据对象在内部分进行浅合并（一层属性深度），在和组件的数据发生冲突时，以组件数据优先。\n")])]),t._v(" "),e("p",[t._v("2.钩子函数的合并")]),t._v(" "),e("pre",[e("code",[t._v("当组件使用的mixins对象有相同的选项时,比如钩子函数，就会被全部合并到一个数组中，因此都会被执行，并且mixins的钩子会先被执行\n")])]),t._v(" "),e("p",[t._v("3.值为对象选项合并")]),t._v(" "),e("pre",[e("code",[t._v("当mixins对象和组件中的选项的值为对象时，比如methods、components和directives，将被混合为同一个对象。当两个对象键名冲突时，组件选项优先。\t\t\n")])]),t._v(" "),e("p",[t._v("使用router-view传递事件 和传递属性  然后在路由加载的组件里面使用 props来接受和使用\n"),t._v('\n<router-view :msg="msg" @tag="a">'),t._v("\n传递属性 必须和传递的变量一样 否则不能使用")]),t._v(" "),e("pre",[e("code",[t._v("\x3c!--路由展示的组件里使用--\x3e\n props:['msg'],\ncreated(){\n    this.$emit('tag')\n}\n")])])])},[],!1,null,null,null);n.default=_.exports}}]);