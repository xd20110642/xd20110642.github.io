(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{307:function(n,e,i){"use strict";i.r(e);var s=i(22),o=Object(s.a)({},function(){var n=this,e=n.$createElement,i=n._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h3",{attrs:{id:"vue-cli3-vue-config-js-配置"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#vue-cli3-vue-config-js-配置","aria-hidden":"true"}},[n._v("#")]),n._v(" vue-cli3 vue.config.js 配置")]),n._v(" "),i("hr"),n._v(" "),i("ul",[i("li",[i("p",[n._v("配置webpack  我们使用插件的地方")]),n._v(" "),i("pre",[i("code",[n._v("config是webpack的实例\nconfigureWebpack:config => {\n    if (process.env.NODE_ENV === 'production') {  // 生产环境\n        //开启压缩\n    config.plugins=[...config.plugins,new CompressionWebpackPlugin({\n        filename: '[path].gz[query]',\n        algorithm: 'gzip',\n        test: productionGzipExtensions,\n        threshold: 10240,\n        minRatio: 0.8\n    }), new BundleAnalyzerPlugin(),new CleanWebpackPlugin()]\n        //配置别名 打包的时候 不会吧vue.js引入 而是需要我们使用cdn的形式 引入 \n        config.externals={\n              //import Vue from 'vue'\n        //  //  key是来源 value是 引入的名字\n        'vue':'Vue',\n         'vueI18n':'VueI18n'\n        }\n    }else {\n        config.plugins=[...config.plugins]\n    }\n},\n")])])]),n._v(" "),i("li",[i("p",[n._v("调整内部的 webpack 配置 链式配置")]),n._v(" "),i("pre",[i("code",[n._v('   chainWebpack: config => { //config依旧是webpack 实例\n  // 设置别名\n  config.resolve.alias\n      .set(\'@\', resolve(\'src\')) // key,value自行定义，比如.set(\'@@\', resolve(\'src/components\'))\n      .set(\'_c\', resolve(\'src/components\'))\n  \n  // 生产环境启用\n  if (process.env.NODE_ENV === \'production\'){\n      //压缩图片\n      config.module\n          .rule("images")\n          .use("image-webpack-loader")\n          .loader("image-webpack-loader")\n          .options({\n              mozjpeg: { progressive: true, quality: 65 },\n              optipng: { enabled: false },\n              pngquant: { quality: "65-90", speed: 4 },\n              gifsicle: { interlaced: false },\n              webp: { quality: 75 }\n          });\n      // 压缩代码    这里是使用的webpack 自带的抽取公共组件的插件 可以分割js减小大小\n      config.optimization.minimizer=[\n          new UglifyJsPlugin({\n              uglifyOptions: {\n                  sourceMap:false,\n                  compress: {\n                      warnings: false,\n                      drop_console: true, //console\n                      drop_debugger: true,\n                      pure_funcs: [\'console.log\'] //移除console\n                  }\n              }\n          })\n      ]\n      // 分割代码  webpack自带压缩\n      config.optimization.splitChunks({\n          // chunks: \'all\',\n          // minSize:0,\n          // minChunks:1,\n          // maxInitialRequests:5,\n          cacheGroups:{\n              vendor:{//node_modules内的依赖库\n                  chunks:"all",\n                  test: /[\\\\/]node_modules[\\\\/]/,\n                  name:"vendor",\n                  minChunks: 1, //被不同entry引用次数(import),1次的话没必要提取\n                  maxInitialRequests: 5,\n                  minSize: 0,\n                  priority:100,\n                  // enforce: true?\n              },\n              common: {// ‘src/js’ 下的js文件\n                  chunks:"all",\n                  test:/[\\\\/]src[\\\\/]js[\\\\/]/,//也可以值文件/[\\\\/]src[\\\\/]js[\\\\/].*\\.js/,\n                  name: "common", //生成文件名，依据output规则\n                  minChunks: 2,\n                  maxInitialRequests: 5,\n                  minSize: 0,\n                  priority:1\n              }\n          }\n      })\n  } \n      // 修复HMR\n      config.resolve.symlinks(true);\n      // 修复Lazy loading routes  按需加载的问题，如果没有配置按需加载不需要写，会报错\n      // config.plugin("html").tap(args => {\n      //   args[0].chunksSortMode = "none";\n      //   return args;\n      // });\n')])]),n._v(" "),i("p",[n._v("},")])])])])},[],!1,null,null,null);e.default=o.exports}}]);