(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{350:function(n,a,e){"use strict";e.r(a);var t=e(22),s=Object(t.a)({},function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数","aria-hidden":"true"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("直接返回一个对象")]),n._v(" "),e("pre",[e("code",[n._v("  var a=() => {} //这样是会报错的 因为 {} 被解释为代码块 如果需要直接返回对象 需要用小括号 包裹起来\n   var a=() => ({}) //ok\n")])])]),n._v(" "),e("li",[e("p",[n._v("在class中定义箭头函数")]),n._v(" "),e("pre",[e("code",[n._v("  class Person{\n      constructor(){\n          this.age=箭头函数\n          this.say=this.say.bind(this) //会实例化 而不是在原型链中\n      }\n      say(){ //声明在原型链中\n\n      }\n      age=() => {// ===> 相当于在构造函数中声明了一个变量\n\n      }\n  }\n")])])])]),n._v(" "),e("p",[n._v("在 "),e("code",[n._v("class")]),n._v(" 里用 = 号声明的变量属于 Field declarations 的语法。对于这种写法声明的变量，其实是会直接挂载到实例的属性上面，而不是挂载到原型链上。")]),n._v(" "),e("p",[n._v("而且 这个也解答了 在"),e("code",[n._v("react")]),n._v(" 中 为什么需要这样声明函数 避免"),e("code",[n._v("this")]),n._v("的丢失 因为这样是挂载到实例属性上面的"),e("br"),n._v("\n为什么会丢失this 是因为react中事件是用回调函数的形式传入的,然后执行回调函数 "),e("code",[n._v("造成了隐式的this丢失")])]),n._v(" "),e("pre",[e("code",[n._v("class React{\n    say(){\n\n    }\n    age(callback){ //可以把onclick 当成age 是同样的道理\n        callback()\n    }\n    render(){\n        return (\n            <div this.age(this.say)>\n        )\n    }\n}\n")])]),n._v(" "),e("p",[n._v("参考文档:")]),n._v(" "),e("ol",[e("li",[n._v("https://juejin.im/post/5eb7961a6fb9a0436d41a8a9")])])])},[],!1,null,null,null);a.default=s.exports}}]);