(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{361:function(n,e,o){"use strict";o.r(e);var t=o(22),r=Object(t.a)({},function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h3",{attrs:{id:"重学js-原型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#重学js-原型","aria-hidden":"true"}},[n._v("#")]),n._v(" 重学js---原型")]),n._v(" "),o("ol",[o("li",[o("p",[n._v("原型("),o("strong",[o("code",[n._v("prototype")])]),n._v("):是"),o("code",[n._v("function对象的一个属性(本身就有自带的)")]),n._v("，他定义了"),o("code",[n._v("构造函数制造出的对象的公共祖先")]),n._v("."),o("code",[n._v("通过该构造函数产生的对象，也可以继续该原型的属性和方法。")])]),n._v(" "),o("ol",[o("li",[n._v("提取共有属性")]),n._v(" "),o("li",[n._v("原型的增删改查\n"),o("ol",[o("li",[n._v("增加\nPerson.prototype={\nheigth=1400;\n}")])])])])]),n._v(" "),o("li",[o("p",[o("strong",[o("code",[n._v("constructor")]),n._v("(构造器):指向 构造函数 系统隐式自带 可以修改(也就是自己)")])])]),n._v(" "),o("li",[o("p",[o("strong",[o("code",[n._v("__proto__")]),n._v(":指向构造函数的原型 可修改")])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("绝大多数对象的原型链最后指向的是Object.prototype")])]),n._v(" "),o("pre",[o("code",[n._v("   function Person(){\n\n }\n var person=new Person()\n Person.prototype={ =====> 对象的原型指向 Object.prototype; \n\n }\n\n 实例对象的__proto__ 指向的是构造函数的原型\n person.__proto__ === Person.prototype\n")])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("实例对象无法修改原型链")])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("创建原型的一个方法 Object.create(原型)")]),n._v("：是添加在原型链上的，(可创建一个没有原型的对象)")]),n._v(" "),o("pre",[o("code",[n._v(" function Person(){}\n\n Person.prototype.name='123'\n 等于\n var obj={name:'123'}\n var  obj1=Object.create(obj);\n 创建一个没有原型的对象\n var obj2=Object.create(null);====> 不会继承Object的原型链\n")])])]),n._v(" "),o("li",[o("p",[o("code",[n._v("call和apply修改this指向 bind是绑定this")])]),n._v(" "),o("pre",[o("code",[n._v(" 任何一个方法都可以进行.call 和 .apply .bind 他们都是一个方法\n function test(){}\n test() ==== test.call() 是等价的 call和apply 是可以忽略的\n\n call 第一个参数 就是this 后面是参数 用 ===>call(this)  用call 里面的this去替换 原本默认的this\n funtion Person(name,age){\n     //  this==obj;\n     this.name=name;\n     this.age=age\n }\n var person=new Person('小米',10); // 这里的this指向person \n var obj={}\n\n Person.call(obj,'魅族',20);\n\n 由于使用了 call 来修改this的绑定  那么 构造函数里面的this 就变成了 obj 然后 魅族就是name的实参 20也是age的实参 \n\n\n function Person(name,age,sex){\n     // this === Student实例化的对象   \n     //person.name=name;\n this.name=name;\n this.age=age;\n this.sex=sex\n }    \n function Student(name, age, sex,tel,grade){\n     // Person中的this 被修改为 通过Student实例化的对象 \n     Person.call(this,name,age,sex); //相对于继承了\n     this.tel=tel;\n     this.grade= grade;\n }    \n")])]),n._v(" "),o("p",[n._v("var person=new Student('小米',20,'男',131,123);")])])]),n._v(" "),o("hr"),n._v(" "),o("pre",[o("code",[n._v("    function Person(){\n        //构造函数隐式操作3步\n        // var this={\n        //  __proto__:Person.prototype    链接到自己的原型 理解为原型链的方向指引  也就是用它查找原型链\n        //}\n        // return this;\n    }\n   \n    Person.prototype={\n        constructor:Person() //系统隐式添加  可以修改\n    }\n    var person=new Person();\n\n    person.__proto__ ===>  Person.prototype\n\n    Person.prototype 是一个对象 \n    里面包含了constructor: ƒ Person()\n    属性是 constructor   值是 构造函数 Person()\n")])]),n._v(" "),o("p",[n._v("举例:")]),n._v(" "),o("pre",[o("code",[n._v(" Person.prototype.name='123'\n  function Person(){\n         // var this={\n        //  __proto__:Person.prototype  \n        //}\n  }\n  var person=new Person(); \n\n  Person.prototype={\n      name:'456'\n  }\n  person.name ====> 123 \n  类似    var obj={name:1} obj1=obj  obj={name:'2'}     obj===> {name:1}\n  Person.prototype={}\n  __proto__=Person.prototype\n  Person.prototype={name:'123'} 但是不影响__proto__的指向\n    因为 __proto__ 和 Person.prototype 指向的是同一个空间内存地址 \n    但是   Person.prototype 的指向被修改了 但是不影响 __proto__ 指向地址 所以为 123\n变形:\nPerson.prototype={\n      name:'456'\n  }\n var person=new Person(); \nperson.name ====> 456 \n为什么会是这个值? 是因为只有在 new 的时候才会 进行 __proto__ 和 prototype的绑定 如果是在new 之前改变 prototype的指向 那么会影响到最终的值  如果是在之后 进行改变prototype的指向 则不会影响原型链查找\n")])]),n._v(" "),o("p",[o("img",{attrs:{src:"https://www.crazyming.com/wp-content/uploads/2019/10/201606071535566.jpg"}}),n._v(" 原型链导图")])])},[],!1,null,null,null);e.default=r.exports}}]);