(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{392:function(e,n,t){"use strict";t.r(n);var o=t(22),a=Object(o.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"vue3-0第二次学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0第二次学习","aria-hidden":"true"}},[e._v("#")]),e._v(" vue3.0第二次学习")]),e._v(" "),t("h4",{attrs:{id:"笨鸟先飞-以勤补拙"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#笨鸟先飞-以勤补拙","aria-hidden":"true"}},[e._v("#")]),e._v(" (笨鸟先飞,以勤补拙)")]),e._v(" "),t("hr"),e._v(" "),t("ul",[t("li",[e._v("state更名为reactive\n"),t("ul",[t("li",[t("p",[t("code",[e._v("创建响应式对象,这个state创建的响应式对象并不是包装对象，不需要使用.value来取值。相当于2.x里面data 中定义的变量")])]),e._v(" "),t("pre",[t("code",[e._v("const obj = reactive({ count: 0 });\nconsole.log(obj.count) //0\n")])])])])]),e._v(" "),t("li",[e._v("value更名为ref，并提供isRef和toRefs  "),t("strong",[e._v("创建一个包装对象 是针对基本类型使用的 如果是引用类型  那么会使用reactive 转为响应式对象")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("以前声明一个包装对象是 "),t("code",[e._v("const a=value(0)")]),e._v("  现在是"),t("code",[e._v("const count=ref(0)")])])]),e._v(" "),t("li",[t("p",[e._v("也是只具备一个响应属性"),t("code",[e._v("value")]),e._v(","),t("code",[e._v("如果将对象指定为ref的值，那么该对象就会被reactive方法深度遍历")])]),e._v(" "),t("pre",[t("code",[e._v("  ref是用于声明基础数据类型的 \n  reactive是用于声明引用数据类型的\n\n  const count = ref(0);\n  console.log(count.value); // 0\n  count.value++;\n  console.log(count.value); // 1\n")])])]),e._v(" "),t("li",[t("p",[e._v("isRef 用于检查一个对象是否是ref对象 也就是包装对象")]),e._v(" "),t("pre",[t("code",[e._v("  const unwrapped = isRef(foo) ? foo.value : foo;\n")])])]),e._v(" "),t("li",[t("p",[e._v("toRefs "),t("code",[e._v("toRefs 可以将 reactive 对象的每个属性都转换为 ref 对象，这样可以实现对象被解构或者展开的情况下，不丢失响应")]),e._v("(转换为基本类型,这样解构和展开复制 就是基本类型的传递 也就是值拷贝 这样就可以保证响应式不丢失)")]),e._v(" "),t("pre",[t("code",[e._v("  function useMousePosition() {\n      const pos = reactive({\n      x: 0,\n      y: 0\n      });\n\n      // ...\n      return toRefs(pos); \n      }\n\n      // x 和 y 现在具备了响应式\n      const { x, y } = useMousePosition();\n")])])])])])]),e._v(" "),t("hr"),e._v(" "),t("pre",[t("code",[e._v("            // 使用toRefs 转换\n            const state = reactive({count: 1});//声明响应式对象\n            const stateRef = toRefs(state) // 转换成了 Reactive<{count: Ref<state.count>}> 转换成了包装对象\n\n            // 这时候可以安全地进行解构和传递属性\n            const { count } = stateRef\n\n            count.value    // 1 解构出来也是包装对象 所以也需要使用.value来完成取值\n            state.count    // 1 三者指向同一个值 响应式对象不需要使用.value\n            stateRef.count.value // 1   这里是转换成了包装对象 所以取值需要使用.value\n\n            state.count++ // 更新源 state\n            count.value   // 2 响应到 ref\n")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("watch可作用于单一函数:"),t("code",[e._v("watch(数据源,回调函数)")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("就是可以不用指定数据来源 根据watch的回调函数里面的依赖关系 来执行("),t("strong",[e._v("不是很理解")]),e._v(")")]),e._v(" "),t("pre",[t("code",[e._v("      watch(() => console.log(count.value)) 就是我们不用指定观察那个数据 vue自己可以回调函数里面的内容 自己触发\n")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("watch的数据来源")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("一个返回任意值的函数")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("一个包装对象 (不需要.value) 注意是包装对象 而不是响应式对象 如果是响应式对象 那么就需要使用第一个注意点")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("一个包含上述两种数据源的数组")])]),e._v(" "),t("pre",[t("code",[e._v("   2.x版本\n   watch:{\n      name(){\n\n      }         \n   }\n   3.x版本\n   const state = reactive({ count: 0 })\n   //清除监听 在参数中作为第三个参数传递进去\n   watch(() =>state.count,(newValue,oldValue,onCleanup)  => {\n           onCleanup(() => {\n           //清除监听的回调\n           })\n   } ); //这个就是观察count的值的变化 \n\n   数据来源举例:\n   如果是基本类型转换的包装对象  那么观察的可以是包装对象\n   const count=ref(0);\n   watch(count,(newValue,oldValue) => {})\n   如果是响应式对象 那么就必须使用 返回响应式对象的某个属性的函数来观察\n   const state=reactive({name:'小米'})\n   watch(() => state.name,(newValue,oldValue) => {})\n")])])])])]),e._v(" "),t("li",[t("p",[e._v("停止监听")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("当watch一个组件的过程中调用setup()函数，观察者链接到组件的生命周期，当组件卸载将自动停止。")])]),e._v(" "),t("li",[t("p",[e._v("不在组件的生命周期里面 就需要我们自己手动停止观察")]),e._v(" "),t("pre",[t("code",[e._v(" const stop = watch(() => { /* ... */ })\n stop() //停止观察\n")])])])])])])]),e._v(" "),t("li",[t("p",[e._v("computed 可传入get和set，用于定义可更改的计算属性 返回的就是ref对象")]),e._v(" "),t("pre",[t("code",[e._v("  const count = ref(1);\n  const plusOne = computed({//这个\n  get: () => count.value + 1,\n  set: val => { count.value = val - 1 }\n  });\n\n  plusOne.value = 1;\n  console.log(count.value); // 0\n")])])])]),e._v(" "),t("hr"),e._v(" "),t("pre",[t("code",[e._v("    2.x\n    computed:{\n           name(){//函数声明式\n\n           } \n    }\n    3.x  //函数表达式  里面的匿名函数等于 上面的具名函数 也就是name\n    const a=computed(() => {\n\n    })\n")])]),e._v(" "),t("ul",[t("li",[e._v("参考文章")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5d836458f265da03d871f6e9",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.im/post/5d836458f265da03d871f6e9"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://vue-composition-api-rfc.netlify.com/api.html#watch",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://vue-composition-api-rfc.netlify.com/api.html#watch"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5dc820a3e51d4509320d084d#heading-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("特别通俗易懂的技术文章"),t("OutboundLink")],1)])])])},[],!1,null,null,null);n.default=a.exports}}]);