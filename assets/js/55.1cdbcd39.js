(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{324:function(n,t,e){"use strict";e.r(t);var l=e(22),i=Object(l.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"改变this的方法-学习笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改变this的方法-学习笔记","aria-hidden":"true"}},[n._v("#")]),n._v(" 改变this的方法(学习笔记)")]),n._v(" "),e("ul",[e("li",[e("p",[e("code",[n._v("call")]),n._v("方法在使用一个指定的 this 值和若干个指定的参数值(非数组)的前提下调用某个函数或方法。")]),n._v(" "),e("pre",[e("code",[n._v("  var foo={\n      value:1\n  }\n  var value=2;\n  function bar(){\n      console.log(this.value)\n  }\n  bar() ===> 2 \n  bar.call(foo) ==> 1 \n")])])])]),n._v(" "),e("p",[n._v("因为我们使用 call 改变了this的指向  call "),e("code",[n._v("第一个参数将作为函数运行时的this 后面是传入的参数")])]),n._v(" "),e("ul",[e("li",[e("p",[e("code",[n._v("bind()")]),n._v(" 方法会创建一个新函数。当这个新函数被调用时，"),e("code",[n._v("bind() 的第一个参数将作为它运行时的 this")]),n._v("，"),e("code",[n._v("之后的一序列参数将会在传递的实参前传入作为它的参数")]),n._v("。(来自于 MDN )")]),n._v(" "),e("pre",[e("code",[n._v("  我们普通的函数就是隐式调用这个bind方法\n  function key(){console.log(this)}  ===>   key.bind(window) this指向window\n")])]),n._v(" "),e("ul",[e("li",[n._v("返回一个函数")]),n._v(" "),e("li",[n._v("可传参")])])]),n._v(" "),e("li")])])},[],!1,null,null,null);t.default=i.exports}}]);