(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{358:function(n,t,r){"use strict";r.r(t);var e=r(22),u=Object(e.a)({},function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h3",{attrs:{id:"闭包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),r("ol",[r("li",[n._v("什么是闭包:\n"),r("ul",[r("li",[n._v("闭包就是函数中的函数(其他语言不能函数再套函数),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。")]),n._v(" "),r("li",[n._v("就是在 A 函数内部，存在 B 函数， B函数 在 A 函数 执行完毕后再执行。B执行时，访问了已经执行完毕的 A函数内部的变量和函数\t(闭包是函数A的执行环境 以及 执行环境中的函数 B组合而构成的)  通过作用链访问fa中的函数")]),n._v(" "),r("li",[n._v("闭包的关键就在，外部的函数执行完毕后，内部的函数再执行，并访问了外部函数内的变量。")])])]),n._v(" "),r("li",[n._v("闭包形成的条件\n"),r("ul",[r("li",[n._v("函数的嵌套")]),n._v(" "),r("li",[n._v("内部函数引用外部函数的局部变量")])])]),n._v(" "),r("li",[n._v("闭包的特性\n"),r("ul",[r("li",[r("p",[n._v("每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境。")]),n._v(" "),r("pre",[r("code",[n._v("  //例题2\n  function outer(x){\n    function inner(y){\n    console.log(x+y);\n    }\n  return inner;\n  }\n  var inn=outer(3);//数字3传入outer函数后，inner函数中x便会记住这个值\n  inn(5);//当inner函数再传入5的时候，只会对y赋值，所以最后弹出8\n  \n  //例题1\n  var inner;\n  function outer(){\n  var a=250;\n  inner=function(){\n  alert(a);//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250\n    }\n  }\n  outer();\n  var a=300;\n  inner();//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。\n")])])])])]),n._v(" "),r("li",[n._v("闭包的内存泄漏\n"),r("ul",[r("li",[r("p",[n._v("全局作用域----只有当页面关闭的时候全局作用域才会销毁")])]),n._v(" "),r("li",[r("p",[n._v("私有的作用域----只有函数执行才会产生")])]),n._v(" "),r("li",[r("p",[r("strong",[n._v("一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会销毁")])]),n._v(" "),r("pre",[r("code",[n._v("  \tfunction fn(){\n  \tvar num=100;\n  \treturn function(){\n  \t  }\n  \t}\n  \tvar f=fn();//fn执行形成的这个私有的作用域就不能再销毁了\n")])]),n._v(" "),r("p",[n._v("闭包使用完了后，要立即释放资源，将引用变量指向null")]),n._v(" "),r("pre",[r("code",[n._v("  \t  function outer(){\n    var num=0;//内部变量\n    return function add(){//通过return返回add函数，就可以在outer函数外访问了\n    num++;//内部函数有引用，作为add函数的一部分了\n    console.log(num);\n    };\n   }\n    var func1=outer();\n    func1();//实际上是调用add函数， 输出1\n    func1();//输出2 因为outer函数内部的私有作用域会一直被占用\n    var func2=outer();\n    func2();// 输出1  每次重新引用函数的时候，闭包是全新的。\n    func2();// 输出2  \n")])])])])]),n._v(" "),r("li",[n._v("判断是否是闭包:\n"),r("ol",[r("li",[n._v("两个函数。有内函数 和 外函数。")]),n._v(" "),r("li",[n._v("外函数执行完毕后，内函数 还没有执行")]),n._v(" "),r("li",[n._v("当内函数执行时（通过外部引用或者返回内函数），访问了 外函数内部的 变量，函数等（说是访问，其实内函数保存着外函数的活动对象，因此，arguments对象也可以访问到）。")])])]),n._v(" "),r("li",[n._v("参考文章:\n"),r("ol",[r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000015624449",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://segmentfault.com/a/1190000015624449"),r("OutboundLink")],1)])])])])])},[],!1,null,null,null);t.default=u.exports}}]);