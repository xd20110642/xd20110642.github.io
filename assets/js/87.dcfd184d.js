(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{356:function(n,o,e){"use strict";e.r(o);var a=e(22),t=Object(a.a)({},function(){var n=this,o=n.$createElement,e=n._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"重学js-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重学js-函数","aria-hidden":"true"}},[n._v("#")]),n._v(" 重学js----函数")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("声明函数的方式:")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("函数声明式:\nfuntion test(){")]),n._v(" "),e("p",[n._v("}")])]),n._v(" "),e("li",[e("p",[n._v("函数表达式(匿名函数表达式):\nvar test=funtion(){")]),n._v(" "),e("p",[n._v("}")])])])]),n._v(" "),e("li",[e("p",[n._v("函数的组成:函数名称、参数(形参、实参)、返回值")]),n._v(" "),e("pre",[e("code",[n._v(" function test(a,b){\n     // 隐式声明了2个变量 没有赋值 var a;var b;\n     // 也称形参\n     \n }\n\n test(1,2); //给a赋值为1 b赋值为2 也称 实参\n\n js中函数参数为不定参数 如何获取函数中的多余的实参呢？\n es5中使用 arguments 伪数组 ---- 实参列表 [1,2] 来获取\n es6中使用 ...rest方式来获取不定参数 实参 是数组类型\n\n 举例说明:\n funtion test(a){//形参为1个\n\n }\n test(1,2); //实参为2个\n 那么多了一个实参 但是函数不会报错 为什么 因为js函数为不定参 在es5中使用 arguments 来获取 arguments[1]; ---\x3e 打印2 如果修改了arguments[1]=3 那么也就是改了形参a的值\n es6中使用 ...rest 来获取不定参\n")])])]),n._v(" "),e("li",[e("p",[n._v("预编译")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("函数声明整体提升")])]),n._v(" "),e("li",[e("p",[n._v("变量 声明提升")]),n._v(" "),e("pre",[e("code",[n._v("  var a=123 ==> var a;\n                a=123;\n")])])]),n._v(" "),e("li",[e("p",[n._v("声明的全局变量 全是window的属性")]),n._v(" "),e("pre",[e("code",[n._v("  var a=123; \n  console.log(a) === window.a\n")])])]),n._v(" "),e("li",[e("p",[n._v("任何变量,如果变量未经声明就赋值,此变量就为全局对象所以。(如果是严格模式中 那么就是当前作用域的全局对象)")]),n._v(" "),e("pre",[e("code",[n._v("  a=1; ===> 挂载到当前作用域上\n  var a=b=2; ===> 把2 赋值给b  b是没有声明就赋值 所以挂载到window对象上,然后在把 b的值赋值给a a是先声明在赋值的 所以 就没有挂载到window上\n")])])]),n._v(" "),e("li",[e("p",[n._v("函数预编译过程(在函数执行的前一刻):")]),n._v(" "),e("ul",[e("li",[e("p",[e("code",[n._v("创建AO对象(执行上下文)")])])]),n._v(" "),e("li",[e("p",[e("code",[n._v("找到形参和变量的声明,将 **变量** 和 **形参名** 作为AO属性名,值为undefined")])])]),n._v(" "),e("li",[e("p",[e("code",[n._v("将实参值和形参统一")])])]),n._v(" "),e("li",[e("p",[e("code",[n._v("在函数体里面找函数声明,**值** 赋予函数体")])]),n._v(" "),e("pre",[e("code",[n._v("  function test(a,b){\n      console.log(a) => function a() {}\n      console.log(b) => undeifned\n      var b= 234; \n      console.log(b) => 234\n      a=123;\n      console.log(a) => 123\n      function a(){}\n      var a;\n      b=234;\n      var b=function (){}\n      console.log(a) => 123\n      console.log(b) => funciton() {}\n  }\n  test(1);\n  AO 对象{ //初始化值\n      a:function() {}\n      b:undeifned\n  }\n")])]),n._v(" "),e("hr"),n._v(" "),e("pre",[e("code",[n._v("  golbal=100\n  function fn(e){\n      console.log(e) => 1;\n      arguments[0]=5; //修改arguments[0] 也就是修改了形参的值\n      console.log(e) ===> 5\n      console.log(golbal); ==> undefind\n      gobal=200;\n       console.log(golbal); ==> 200\n       var global=300 \n  }\n  fn(1)\n  var global;\n\n  go{                         AO{\n      global:undeifned,       gobal:undefind\n      fn:function(){\n\n      }                       }\n  }\n")])]),n._v(" "),e("hr"),n._v(" "),e("pre",[e("code",[n._v("  function bar(){\n      return foo; ==> funtion(){}\n      foo =100;\n      function foo(){}\n      var foo=1\n   }\n")])])])])])])]),n._v(" "),e("li",[e("p",[n._v("作用域")]),n._v(" "),e("ol",[e("li",[e("p",[e("strong",[n._v("作用域链")]),n._v(":作用域中存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这个链式链接叫做作用域链。")])]),n._v(" "),e("li",[e("p",[e("strong",[n._v("运行期上下文")]),n._v(":当函数执行时，会创建一个称为"),e("strong",[n._v("执行期上下文")]),n._v("的内部对象。一个执行期上下文定义了一个函数执行时的环境,"),e("strong",[n._v("函数每次执行时对应的执行上下文都是独一无二的")]),n._v("，所以多次调用一个函数会导致创建多个执行上下文,"),e("strong",[n._v("当函数执行完毕,它所产生的执行上下文被销毁。")])])]),n._v(" "),e("li",[e("p",[e("strong",[n._v("查找变量")]),n._v(":"),e("strong",[n._v("从作用域链的顶端依次向下查找")]),n._v("(通俗点讲 孙子可以找爷爷 爸爸 拿压岁钱  爷爷和爸爸 不能找孙子拿钱  而且孙子一出生 就拥有爷爷和爸爸的财富  反过来就不行)")]),n._v(" "),e("pre",[e("code",[n._v("function a(){              \n    function b(){\n        var b=234;\n    }\n    var a=123;\n    b()\n}\nvar glob=100;\na();\n\n                    由AO2 -> AO1 -> GO 就构成了一个完整的作用域链\n\nGO{ //全局作用域       <----  AO1{//函数a的作用域       <-----     AO2{ //这个函数b的作用域\n    a:function (){              b:function(){                       b:234\n\n    },                            },\n    glob:100                        a:123\n}                                  }                                }\n")])]),n._v(" "),e("hr")])])]),n._v(" "),e("li",[e("p",[e("strong",[n._v("闭包:但凡是内部的函数保存到了外部,则一定生成闭包。")]),n._v("(对象里面的方法被返回到外部,也产生了闭包 简而言之 只要函数被返回 就产生了闭包)")]),n._v(" "),e("pre",[e("code",[n._v(" function a() {  //闭包\n     function b(){\n         var bbb=234;\n         console.log(aaa)\n     }\n     var aaa=123;\n     return b;\n }\n var glob=100;\n var demo=a();\n demo()\n                             a作用链                          b作用链\n GO{                         a:---\x3e 0 AO: aaa=123        b: ----\x3e  0 bAO: bbb=234\n     glob:100,                      1 GO: glob=100                 1 aAo: aaa=123  \n     demo:function                                                 2 GO : glob=100 \n }\n a函数执行完毕 也就是return b函数后 a函数销毁自己的作用链  但是b的执行上下文 关联着 a的上下文 所以 b里面的函数能够读取到a里面的上下文 也能报存a的记录  所以这个就是闭包的原理\n")])]),n._v(" "),e("hr"),n._v(" "),e("pre",[e("code",[n._v(" function a(){\n     var num=100;\n     funtion b(){\n         num++;\n         console.log(num)\n     }\n     return b;\n }\n var demo=a()\n demo();// 101\n demo();// 102\n                             a作用链                                     b作用链\n GO{                         a:----\x3e 0 aAO: num=100          b:----\x3e 0 bAO :没有任何东西\n     demo:function                   1 GO demo:function              1 aAO:num=100 \n }                                                                   2 GO demo:funtion\n a函数执行完毕 也就是return b函数后 a函数销毁自己的作用链  但是b的执行上下文 关联着 a的上下文 所以 b里面的函数能够读取到a里面的上下文 也能报存num的记录  \n")])]),n._v(" "),e("ol",[e("li",[n._v("闭包的作用:\n"),e("ul",[e("li",[e("p",[n._v("实现公用变量")])]),n._v(" "),e("li",[e("p",[n._v("做缓存")]),n._v(" "),e("pre",[e("code",[n._v("  function test(){\n      var num=100;\n      funtion a(){\n          num++;\n          console.log(num) // 101\n      }\n      function b(){\n          num--;\n          console.log(num) //100\n      }\n      return [a,b]\n  }    \n  var myArr=test();\n  myArr[0]();\n  myArr[1]();\n\n  GO{                test: ----\x3e 0 testAO num=100;      a:----\x3e 0 aAO  \n                                 1 GO                           1 testAO num=100\n  }                                                             2 GO\n  b: ----\x3e 0 bAO\n           1 testAO num=100;\n           2 GO    \n  test函数执行完毕以后,test上下文销毁 但是 a b 还关联着test的上下文    \n")])])])])])])]),n._v(" "),e("li",[e("p",[n._v("立即执行函数:此类函数没有做声明,在一次执行过后即释放.适合做初始化工作")]),n._v(" "),e("pre",[e("code",[n._v("var name = (function(a,b,c){ //name是用于接收返回值的\n    return a+b;\n     console.log(a+b);\n }(1,2,3));\n\n for(var i=0;i<10;i++){\n     (function(j){\n         // j=0\n         arr[j]=function(){\n             //因为j 被报存到了立即执行函数里面\n             console.log(j)\n         }\n     }(i))\n }\n")])]),n._v(" "),e("p",[n._v("备注:\n1. 只有表达式才能被执行符号执行; ---------\x3e (执行符号是"),e("code",[n._v("()")]),n._v(");\n2. 能被执行符号执行的"),e("strong",[n._v("函数表达式")]),n._v(",函数名可以被自动忽略")]),n._v(" "),e("pre",[e("code",[n._v("     var test=function (){                funtion test() {}()  ----\x3e 不能执行 会报错\n\n     }() ----\x3e 可以执行\n\n     + funtion(){}() ---\x3e `+` 加一个变量 就变成了 表达式  然后表达式就可以被执行了\n\n     (function(){}())   ----\x3e 最外面的括号是一个 运算表达式   理由同上")])])])])])},[],!1,null,null,null);o.default=t.exports}}]);