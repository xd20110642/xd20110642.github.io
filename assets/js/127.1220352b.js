(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{397:function(t,n,e){"use strict";e.r(n);var o=e(22),r=Object(o.a)({},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"vuex再次学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex再次学习","aria-hidden":"true"}},[t._v("#")]),t._v(" vuex再次学习")]),t._v(" "),e("p",[t._v("1 基本类型")]),t._v(" "),e("pre",[e("code",[t._v("state 用来数据共享数据存储\nmutation 用来注册改变数据状态\ngetters 用来对共享数据进行过滤操作\naction 解决异步改变共享数据\n")])]),t._v(" "),e("p",[t._v("2 初始化以及注入实例对象")]),t._v(" "),e("pre",[e("code",[t._v("\tconst store = new Vuex.Store({\n     state:{//这个就相当于是组件里面的data对象\n         count:0,\n     },\n     mutations:{//这个就相当于是组件里面的methods方法\n         increat(state){//这个必须接受一个参数state\n            state.count++\n         }\n     }\t\n\t})\n\t\n\tvar vm=new Vue({\n\tstore,//注入实例化  这个是全局注册vuex，也可以不全局注册  然后在我们需要的组件中    impront 即可\n\t\n\t})\n\t//通过 this.$store.\n")])]),t._v(" "),e("p",[t._v("3 使用mutation方法,也就相当于组件的methods方法 "),e("strong",[t._v("这个是同步修改数据，如果是异步修改数据的话，数据是不会修改的")])]),t._v(" "),e("pre",[e("code",[t._v("\t导出\n\texport default{\n\tobejtc是参数  单一参数就是可以 ，多个参数为对象\n\t\tin(state,obejct){\n\t\t\t\n\t\t}\n\t}\n\t//使用\n\tthis.$store.commie('name'，‘参数’)\n")])]),t._v(" "),e("p",[t._v("4 使用getter方法,也就是相当于是计算属性")]),t._v(" "),e("pre",[e("code",[t._v("\t导出\n\texport default{\n\t\tdoneTodos（state）{\n\t\treturn state.xxx.filter( () => {\n\t\t\n\t\t})\n\t\t}\n\t}\t\n\t\n\t//使用   doSome不带括号\n\t return this.$store.getters.doSome\t\n")])]),t._v(" "),e("p",[t._v("5 使用action方法,是异步修改数据"),e("br"),t._v(" "),e("strong",[t._v("异步修改数据流程    action => mutation => state")])]),t._v(" "),e("pre",[e("code",[t._v("导出\nexport default{\n//参数一:context 这个是固定的写法  通过context来访问：mutation getter state中的内容\n//\ndoSome(context,参数的参数){\n\tsettimeOut(\t()=>{\n\t//这个是调用的mutation中的方法\n\tcontext.commit('方法名',传入对的参数)\n\t},1000)\n\n}\n}\n\n//使用\nreturn this.$store.dispatch('定义的名字')")])])])},[],!1,null,null,null);n.default=r.exports}}]);