(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{299:function(t,e,n){"use strict";n.r(e);var o=n(22),s=Object(o.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"vue中自适应高度过渡展示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue中自适应高度过渡展示","aria-hidden":"true"}},[t._v("#")]),t._v(" vue中自适应高度过渡展示")]),t._v(" "),n("hr"),t._v(" "),n("ul",[n("li",[n("p",[t._v("在一个业务中需要展示过渡效果,即高度自适应 而不是固定高度。所以就不能"),n("code",[t._v("高度写死,在没有显示的时候将高度设置为0，点击展示的时候 在将高度设置为原本高度 这样就可以动态展示过渡效果了。")]),t._v("那么在高度不确定的情况下我们应该怎么办呢?")]),t._v(" "),n("pre",[n("code",[t._v("  在vue的mounted生命周期里面:\n  我们使用  $nextTick 这个方法 提前获取到DOM更新完毕的节点的高度 然后将高度保存到一个变量中 然后再讲DOM高度设置为0 \n  为什么我们要这样做?因为display:none 我们是获取不到高度的 只有为block我们才能获取到高度\n       this.$nextTick(() => {\n       const con=document.querySelector('.content');\n       this.showHeight=con.clientHeight;\n       con.style.height=`0px`;\n      })\n")])])])])])},[],!1,null,null,null);e.default=s.exports}}]);