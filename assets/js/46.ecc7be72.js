(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{316:function(e,t,n){"use strict";n.r(t);var o=n(22),s=Object(o.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"阻止移动端滚动穿透"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#阻止移动端滚动穿透","aria-hidden":"true"}},[e._v("#")]),e._v(" 阻止移动端滚动穿透")]),e._v(" "),n("ul",[n("li",[e._v("在我们使用弹窗的时候,会发现弹层出来了,我们滚动依旧会触发下面body的滚动,这个就是我们所说的滚动穿透")]),e._v(" "),n("li",[e._v("有三个方法 可以解决这个问题\n"),n("ul",[n("li",[n("p",[e._v("第一个:css属性")]),e._v(" "),n("ul",[n("li",[e._v("使用新增css属性overscroll-behavior: contain 就可以解决滚动穿透的问题\n但是兼容性不好,在iOS端全军覆没,安卓webview 需要较高版本")])])]),e._v(" "),n("li",[n("p",[e._v("第二个:阻止touchmove事件 (当然弹框里面的内容也不能滚动了)")]),e._v(" "),n("pre",[n("code",[e._v('  <div class="dialog"  @touchmove.prevent="test">\n  <div class="dialog-mask"></div>\n  <div class="dialog-conent">\n  </div>\n  </div>\n  我们需要在最外层的div 阻止掉touchmove的默认事件 就可以阻止滚动了\n  ps:在小程序端我们需要阻止 catchtouchmove 这个事件\n')])])]),e._v(" "),n("li",[n("p",[e._v("第三种:也是阻止touchmove事件 (弹框里面的内容可以滚动)")]),e._v(" "),n("pre",[n("code",[e._v('   <div class="dialog-mask" @touchmove.prevent.stop="test"></div>\n   <div class="dialog-conent">\n   mask和conent必须是同级的   \n')])])])])])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5c2dc9cce51d45690a254b79",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考文章"),n("OutboundLink")],1)])])},[],!1,null,null,null);t.default=s.exports}}]);