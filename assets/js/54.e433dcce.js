(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{323:function(t,e,n){"use strict";n.r(e);var r=n(22),a=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"async-await函数-（是generator的语法糖）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async-await函数-（是generator的语法糖）","aria-hidden":"true"}},[t._v("#")]),t._v(" async/await函数 （是Generator的语法糖）")]),t._v(" "),n("pre",[n("code",[t._v("\t1.只有async\n\tasync funtion name(){   ====       funtion name(）{\n\treturn 'hello\t\t\t\t\t\t\t\treturn Promise.resolve('hello')\t\t\t\t\t\t\t\n\t}\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\tname().then((res) => {      \n\t\tconsole.log(res)\n\t})\t\t\t\n")])]),t._v(" "),n("h3",{attrs:{id:"async"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async","aria-hidden":"true"}},[t._v("#")]),t._v(" async")]),t._v(" "),n("p",[n("strong",[t._v("async 函数返回的是一个 Promise 对象")])]),t._v(" "),n("h3",{attrs:{id:"从文档中也可以得到这个信息。async-函数（包含函数语句、函数表达式、lambda表达式）会返回一个-promise-对象，如果在函数中-return-一个直接量，async-会把这个直接量通过-promise-resolve-封装成-promise-对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#从文档中也可以得到这个信息。async-函数（包含函数语句、函数表达式、lambda表达式）会返回一个-promise-对象，如果在函数中-return-一个直接量，async-会把这个直接量通过-promise-resolve-封装成-promise-对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象")]),t._v(" "),n("p",[t._v("--\n个函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。")]),t._v(" "),n("pre",[n("code",[t._v("\tasync function f() {\n\t\treturn 1\n\t}\n\tf().then(alert) // 1async function f() {\n\t\treturn 1\n\t}\n\tf().then(alert) // 1\n")])]),t._v(" "),n("h3",{attrs:{id:"await"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#await","aria-hidden":"true"}},[t._v("#")]),t._v(" await")]),t._v(" "),n("p",[t._v("如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果（就是只返回正确的值）")]),t._v(" "),n("p",[t._v("--\nwait可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行")]),t._v(" "),n("pre",[n("code",[t._v("async function f() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve('done!'), 1000)\n    })\n    let result = await promise // 直到promise返回一个resolve值（*）\n    alert(result) // 'done!' \n}\nf()\n")])]),t._v(" "),n("p",[t._v("const a =await xx()    ===> xx().then().cath()")]),t._v(" "),n("pre",[n("code",[t._v('\ttest1(){\n\treturn new Promise(resolve => {\n\t\tconsole.log("第一")\n\t\tsetTimeout(() => {\n\t\t\tresolve("你好")\n\t\t},5000)\n\t})\n\t},\n\ttest2(){\n\treturn new Promise(resolve => {\n\t\tconsole.log("第二")\n\t\tsetTimeout(() => {\n\t\t\tresolve("你好2")\n\t\t},8000)\n\t})\n\t}\n\nasync test(){//执行\n  const a=await this.test1();\n  console.log("第一回调执行完毕")\n  const b=await this.test2()\n  console.log("第二回调执行完毕")\n  return [a,b]\n}\n//调用\n this.test().then((res) => {\n  console.log("end")\n  console.log("...res",res)\n})\n')])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000007535316?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接1"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000013292562?utm_source=channel-newest",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接2"),n("OutboundLink")],1)])])},[],!1,null,null,null);e.default=a.exports}}]);