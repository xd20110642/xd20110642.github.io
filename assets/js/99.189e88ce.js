(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{366:function(n,a,e){"use strict";e.r(a);var t=e(22),s=Object(t.a)({},function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"react中绑定this的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react中绑定this的原理","aria-hidden":"true"}},[n._v("#")]),n._v(" react中绑定this的原理")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("在 React 的类组件中，"),e("strong",[n._v("当我们把事件处理函数引用作为回调传递过去")]),n._v("，如下所示")]),n._v(" "),e("pre",[e("code",[n._v('  <button type="button" onClick={this.handleClick}>Click Me </button>\n')])]),n._v(" "),e("p",[n._v("事件处理程序方法会丢失其隐式绑定的上下文。当事件被触发并且处理程序被调用时，this的值会回退到默认绑定，即值为 undefined，这是因为类声明和原型方法是以严格模式运行。\n当我们将事件处理程序的 this 绑定到构造函数中的组件实例时，我们可以将它作为回调传递，而不用担心会丢失它的上下文。\n箭头函数可以免除这种行为，因为它使用的是词法 this 绑定，会将其自动绑定到定义他们的函数上下文。")])]),n._v(" "),e("li",[e("p",[n._v("this丢失的原因")]),n._v(" "),e("pre",[e("code",[n._v("  var obj={\n      name:'123',\n      sayName:function(){\n          console.log(this.name)\n      }\n  }\n  \n  obj.sayName() ===> '123'\n")])])])]),n._v(" "),e("p",[n._v("当我们将这个"),e("strong",[n._v("函数引用赋值")]),n._v("给某个其他变量并使用这个新的函数引用去调用该函数时,"),e("code",[n._v("this")]),n._v("就会发生改变.")]),n._v(" "),e("pre",[e("code",[n._v("    var name='小米';\n    var a=obj.sayName;\n    a() ===> '小米'\n    这样就照常this的丢失\n")])]),n._v(" "),e("p",[n._v("再将这些函数以"),e("strong",[n._v("回调的形式传递")]),n._v("给另一个自定义函数、第三方库函数或者像 setTimeout 这样的内置JavaScript函数时，上面提到的判断方法会特别实用。"),e("strong",[n._v("(react就是用回调函数的形式传递的)")])]),n._v(" "),e("pre",[e("code",[n._v("    //setTimeout 的虚拟实现\n    function setTimeout(callback, delay){\n        // var callback\n        // callback=obj.sayName\n      //等待 'delay' 数个毫秒\n\n    callback();\n    }\n\n    setTimeout( obj.sayName, 1000 ); ===> '小米'\n    因为 callback === obj.sayName 的引用值 \n    执行 callback() 就相当于是 window.callback() this指向全局 \n\n    class Person{\n        say(){\n            console.log(this)\n        }\n        ex(callback){\n            callback()\n        }\n        render(){\n            this.ex(this.say)\n        }\n    }\n    var a1=new Person();\n    a1.say() ===> //Person()\n    a1.render() ===> //undefined \n    这个就是react中this丢失模拟。具体原因上面已经分享过了。\n    那么我们如何避免这样的情况呢。\n    class Person{\n        say=() => {\n            console.log(this) //箭头函数定义时就固定了this  箭头函数是根据外层（函数或者全局）作用域来决定this this指向的是父级this\n        }\n        ex(callback){\n            callback()\n        }\n        render(){\n            this.ex(this.say)\n        }\n    }\n    var a1=new Person();\n    a1.say() ===> //Person(){}\n    a1.render() ===> //Person(){} \n    原理:\n    callback = this.say;\n    callback() ===> 因为是使用的箭头函数 指向的是父级this 也就是Person 这样 也就避免了this的丢失\n")])])])},[],!1,null,null,null);a.default=s.exports}}]);