(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{411:function(e,r,n){"use strict";n.r(r);var t=n(22),o=Object(t.a)({},function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"vue-router再次学习"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-router再次学习","aria-hidden":"true"}},[e._v("#")]),e._v(" vue-router再次学习")]),e._v(" "),n("p",[e._v("1 基础知识：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("使用router-link组件来完成导航 也就是跳转,由to来指定跳转的路径")]),e._v(" "),n("pre",[n("code",[e._v(' <router-link to="/foo"></router-link>\n 需要在路径前面加上/\n')])])]),e._v(" "),n("li",[n("p",[e._v("展示路由组件的内容")]),e._v(" "),n("pre",[n("code",[e._v(" <router-view></router-view>\n")])])]),e._v(" "),n("li",[n("p",[e._v("实例化与注册")]),e._v(" "),n("pre",[n("code",[e._v("  var a={template:'<div>123</div>'};\n  var b={template:'<div>456</div>'};\n // 实例化路由组件\n const router = new VueRouter({\n      routes:[\n          {path:'/a',component:a},\n          {path:'/b',component:b}\n      ]\n  })\t\t\t\n  //注入组件\n  var vm=new Vue({\n  router\n  })\t\n")])])])]),e._v(" "),n("p",[e._v("获取参数:通过this.$router 是获取整个路由实例 通过this.$route是获取的当前路由")]),e._v(" "),n("p",[n("strong",[e._v("激活的路由链接 带有.router-link-active 样式 如果需要修改路由样式时")])]),e._v(" "),n("p",[e._v("2 动态路由的使用(也就是传递参数)")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("使用路径参数")]),e._v(" "),n("pre",[n("code",[e._v(" 路径参数使用 : 标记  然后使用 this.$router.params中 然后就可以使用 this.$router.params.xxx来查看\n \n 如果是直接写在组件内部也就不是在js中是使用"+e._s(e.$route.params.id)+"\n")])]),e._v(" "),n("p",[e._v("需改路由匹配路径：就是通过params来获取\n"),n("router-link",{attrs:{to:"/to/100"}})],1),e._v(" "),n("p",[e._v("不需要修改路由匹配规则\n通过query来获取")]),e._v(" "),n("pre",[n("code",[e._v("  <router-link to=\"/foo?'传递的属性名称'=10\" >切换到第一个组件</router-link>\t\n")])])]),e._v(" "),n("li",[n("p",[e._v("子路由")]),e._v(" "),n("pre",[n("code",[e._v(" 定义子路由\n  {\n         path: '/a', component: a,\n      children:[\n         {\n             // 子路由里面不需要加/\n             path:'b',component:b\n         },{\n             path:'c',component:c\n         }\n                  ]\n }\t\t\t \n \t<router-link to=\"/a\">我是a组件</router-link>\n     <router-link to=\"/a/b\">我是a组件b子组件</router-link>\n     <router-link to=\"/a/c\">我是a组件c子组件</router-link>\n")])])])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("根目录中设置的 路由视图 是展示的父组件的展示部分")])]),e._v(" "),n("li",[n("p",[e._v("父组件中设置 路由视图 是展示子路由的部分\n3 编程式的导航")]),e._v(" "),n("p",[e._v('router.push() === :to=""')])])]),e._v(" "),n("ol",[n("li",[n("p",[e._v("链式编程,推送")]),e._v(" "),n("pre",[n("code",[e._v("router.push(\"home\") //字符串\nrouter.push(\"{path:'home}\")//对象\nrouter.push({name:'xx',params:{userId:123}})//令名的路由\nrouter.push({path:'register',query:{plan:'xxx'}})//// 带查询参数，变成 /register?plan=private\n")])])]),e._v(" "),n("li",[n("p",[e._v("传递参数")]),e._v(" "),n("p",[e._v("如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：")]),e._v(" "),n("pre",[n("code",[e._v("router.push({ name: 'user', params: { userId }}) // -> /user/123\t\t因为name在路由注册中就指明了 路径\n")])])])]),e._v(" "),n("p",[e._v("4 令名路由")]),e._v(" "),n("pre",[n("code",[e._v("const router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user', //这个name就是===path 这个路径 \n      component: User\n    }\n  ]\n})\n\n使用 并且传参  传参是     :to 不传参是 to \n<router-link :to=\"{name:'user',params:{userId:123}}\">点击我去其他地方</router-link>\n\nrouter.push({name:'user',params:{userId:123}})\n")])]),e._v(" "),n("p",[e._v("5 嵌套令名视图")]),e._v(" "),n("pre",[n("code",[e._v('routes: [\n   { path: \'/e\', components:{//注意:components 是带s的\n       default:a,//默认展示组件\n       x:b,//路由名字x展示的组件\n       d:c//路由名字d展示的组件\n   }}]\n   使用\n    <router-view ></router-view>\n    <router-view  name="x"></router-view>\n    <router-view  name="d"></router-view>\n')])]),e._v(" "),n("p",[e._v("6 路由组件传参和解耦")]),e._v(" "),n("pre",[n("code",[e._v("使用props来解耦\n\n { path: '/user/:id', component: User, props: true },\n")])]),e._v(" "),n("p",[e._v("7 导航守卫")]),e._v(" "),n("pre",[n("code",[e._v("全局守卫\nto:route => 需要进入的目标用户  也就是终点站\nfrom:route => 正要离开的路由  也就是起点站\nnext:funtion =>过程函数  也就是过程\n\tnext() => 这个是旅程完成 到达了目的地\n\tnext(false) => 这个是终止旅程 回到起始站或者其他地方\n\t\nrouter.beforeEach((to,from,next) => {\n\n})\t\t \t\t")])])])},[],!1,null,null,null);r.default=o.exports}}]);